<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">

  <!-- Touch optimization for iframe embedding -->
  <meta name="touch-action" content="pan-x pan-y">

  <title>Mappedin Conference POC - Production Ready</title>

  <!-- Lucide Icons - Modern outline icons -->
  <script src="https://unpkg.com/lucide@latest"></script>

  <!-- Component Styles -->
  <link rel="stylesheet" href="/css/floor-zoom-controls.css">
  <link rel="stylesheet" href="/css/loading-states.css">
  <link rel="stylesheet" href="/css/directions-card.css">
  <link rel="stylesheet" href="/css/directions-interactive.css">

  <!-- Modular Components -->
  <script src="/js/search-module.js"></script>
  <script src="/js/floor-zoom-controls.js"></script>
  <script src="/js/directions-card.js"></script>
  <script src="/js/directions-interactive.js"></script>

  <script type="module">
    // This will use the local npm packages - CORRECT PATTERN
    import { getMapData, show3dMap } from '@mappedin/mappedin-js';
    import '@mappedin/mappedin-js/lib/index.css';

    window.addEventListener('DOMContentLoaded', async () => {
      const status = document.getElementById('status');
      let mapView, mapData;
      let allLabels = [];
      let labelsVisible = true;
      let exhibitorMarkers = [];
      let accessibleMode = true;  // Default accessible mode ON
      let categoryMarkers = {
        amenities: [],
        restrooms: [],
        rooms: []
      };

      // Label categories with zoom thresholds for progressive disclosure
      let labelCategories = {
        exhibitors: [],      // Always visible (rank: 'always-visible')
        mainAreas: [],       // Visible at zoom >= 18 (rank: 'high')
        amenities: [],       // Visible at zoom >= 20 (rank: 'medium')
        booths: []          // Visible at zoom >= 22 (rank: 'low')
      };

      // Zoom thresholds for label visibility
      const ZOOM_THRESHOLDS = {
        EXHIBITORS: 0,     // Always visible
        MAIN_AREAS: 18,    // Major halls, entrances
        AMENITIES: 20,     // Restrooms, elevators
        BOOTHS: 22         // Individual booth numbers
      };

      let currentZoom = 19; // Track current zoom level

      // Get location by booth number (externalId)
      function getLocationByBooth(boothNumber) {
        if (!boothNumber || !mapData) return null;
        const locations = mapData.getByType('location');
        return locations.find(loc =>
          loc.details?.externalId?.toUpperCase() === boothNumber.toUpperCase()
        );
      }

      // Get all exhibitor locations (locations with both name and externalId)
      function getAllExhibitors() {
        if (!mapData) return [];
        const locations = mapData.getByType('location');
        return locations.filter(loc =>
          loc.details?.name && loc.details?.externalId
        );
      }

      // Get exhibitor data for a booth (returns array for consistency with old co-exhibitor pattern)
      function getExhibitorsByBooth(boothNumber) {
        const location = getLocationByBooth(boothNumber);
        if (!location || !location.details?.name) return [];

        // Return as array with location data
        return [{
          name: location.details.name,
          booth: location.details.externalId,
          location: location  // Include full location object for geometry access
        }];
      }

      try {
        status.textContent = 'Loading map data...';

        // Step 1: Fetch map data from Mappedin API with search enabled
        mapData = await getMapData({
          mapId: '688ea50e362b1d000ba0822b',
          key: 'mik_iND9Ra87M1Ca4DD444be4063d',
          secret: 'mis_esa0RDim6GGkbO2f7m6jNca0ADvFcZc8IzigafkC2dq85341024',
          search: { enabled: true }  // Enable built-in Mappedin search
        });

        status.textContent = 'Rendering 3D map...';

        // Step 2: Initialize 3D map view
        mapView = await show3dMap(
          document.getElementById('mappedin-map'),
          mapData
        );

        // Use the mapData we already fetched (not mapView.mapData)
        const spaces = mapData.getByType('space');

        // Log what data we have for debugging
        console.log('📊 Map Data Summary:');
        console.log('- Total spaces:', spaces.length);
        console.log('- Spaces with externalId:', spaces.filter(s => s.externalId).length);
        console.log('- Sample space data:', spaces[0]);

        // Investigate space properties for restroom detection
        console.log('\n🔍 Investigating space properties for amenity detection:');

        // Check for spaces with specific types
        const spaceTypes = [...new Set(spaces.map(s => s.type).filter(Boolean))];
        console.log('- Unique space types:', spaceTypes);

        // Check for category property
        const spacesWithCategory = spaces.filter(s => s.category);
        console.log('- Spaces with category:', spacesWithCategory.length);
        if (spacesWithCategory.length > 0) {
          const categories = [...new Set(spacesWithCategory.map(s => s.category))];
          console.log('- Unique categories:', categories);
          console.log('- Sample space with category:', spacesWithCategory[0]);
        }

        // Check for tags
        const spacesWithTags = spaces.filter(s => s.tags && s.tags.length > 0);
        console.log('- Spaces with tags:', spacesWithTags.length);
        if (spacesWithTags.length > 0) {
          const allTags = [...new Set(spacesWithTags.flatMap(s => s.tags || []))];
          console.log('- Unique tags:', allTags);
          console.log('- Sample space with tags:', spacesWithTags[0]);
        }

        // Check space names for patterns
        const namedSpaces = spaces.filter(s => s.name);
        console.log('- Spaces with names:', namedSpaces.length);
        const uniqueNames = [...new Set(namedSpaces.map(s => s.name))].slice(0, 20);
        console.log('- Sample space names (first 20):', uniqueNames);

        // Check for specific category that might indicate restrooms
        const roomCategorySpaces = spaces.filter(s => s.category === 'room');
        console.log('- Spaces with category="room":', roomCategorySpaces.length);
        if (roomCategorySpaces.length > 0) {
          console.log('- Sample room category space:', roomCategorySpaces[0]);
          console.log('- First 10 room names:', roomCategorySpaces.slice(0, 10).map(s => s.name || s.externalId));
        }

        // Deep dive: show ALL properties of first space for analysis
        if (spaces.length > 0) {
          console.log('\n🔬 Deep Analysis - ALL properties of first space:');
          const firstSpace = spaces[0];
          console.log('Full space object:', firstSpace);
          console.log('All enumerable properties:', Object.keys(firstSpace));
          console.log('All property values:');
          Object.keys(firstSpace).forEach(key => {
            console.log(`  - ${key}:`, firstSpace[key]);
          });
        }

        // Check for amenities
        const amenities = mapData.getByType('amenity') || [];
        console.log('- Amenities:', amenities.length);
        if (amenities.length > 0) console.log('- Sample amenity:', amenities[0]);

        status.textContent = `✅ Success! Loaded ${spaces.length} spaces`;
        status.style.background = '#28a745';
        status.style.color = 'white';

        setTimeout(() => status.style.display = 'none', 3000);

        // Setup all features
        setupFloorSelector();
        setupLabels();
        setupAmenities();
        setupExhibitors();
        setupSpaceInteractivity();
        setupAccessibility();
        setupDropPin();

        // Setup camera event listener for zoom-based label visibility
        setupCameraZoomListener();
        setupSearch();

        // Setup floor and zoom controls
        setupFloorZoomControls();

      } catch (error) {
        status.textContent = `❌ Error: ${error.message}`;
        status.style.background = '#dc3545';
        status.style.color = 'white';
        console.error(error);
      }

      // Update label visibility based on zoom level
      function updateLabelVisibility(zoomLevel) {
        currentZoom = zoomLevel;

        // Main areas: visible at zoom >= 18
        labelCategories.mainAreas.forEach(label => {
          mapView.updateState(label, { enabled: zoomLevel >= ZOOM_THRESHOLDS.MAIN_AREAS });
        });

        // Amenities: visible at zoom >= 20
        labelCategories.amenities.forEach(label => {
          mapView.updateState(label, { enabled: zoomLevel >= ZOOM_THRESHOLDS.AMENITIES });
        });

        // Booths: visible at zoom >= 22
        labelCategories.booths.forEach(label => {
          mapView.updateState(label, { enabled: zoomLevel >= ZOOM_THRESHOLDS.BOOTHS });
        });

        // Exhibitors: always visible (no update needed)
        console.log(`🔍 Zoom: ${zoomLevel.toFixed(1)} | Labels visible: Exhibitors (${labelCategories.exhibitors.length}), Main Areas (${zoomLevel >= ZOOM_THRESHOLDS.MAIN_AREAS ? labelCategories.mainAreas.length : 0}), Amenities (${zoomLevel >= ZOOM_THRESHOLDS.AMENITIES ? labelCategories.amenities.length : 0}), Booths (${zoomLevel >= ZOOM_THRESHOLDS.BOOTHS ? labelCategories.booths.length : 0})`);
      }

      // Setup camera zoom listener for dynamic label visibility
      function setupCameraZoomListener() {
        mapView.on('camera-change', (event) => {
          const newZoom = event.transform.zoomLevel;

          // Only update if zoom changed significantly (avoid excessive updates)
          if (Math.abs(newZoom - currentZoom) > 0.5) {
            updateLabelVisibility(newZoom);
          }
        });

        console.log('✅ Camera zoom listener initialized for dynamic label visibility');
      }

      // Floor Selector (with buildings/areas if available)
      function setupFloorSelector() {
        const floors = mapData.getByType('floor');
        const buildings = mapData.getByType('building') || [];

        // Log available data for debugging
        console.log('📊 Floor/Building Data:');
        console.log('- Floors:', floors.length, floors.map(f => f.name || f.elevation));
        console.log('- Buildings:', buildings.length, buildings.map(b => b.name));

        if (floors.length <= 1 && buildings.length === 0) {
          console.log('ℹ️ Single floor, no buildings - floor selector hidden');
          return;
        }

        const container = document.getElementById('floorSelectorContainer');
        const floorSelect = document.getElementById('floorSelect');

        container.style.display = 'block';
        floorSelect.innerHTML = '';

        // Add buildings as optgroups if available
        if (buildings.length > 0) {
          buildings.forEach(building => {
            const optgroup = document.createElement('optgroup');
            optgroup.label = `🏢 ${building.name || 'Building'}`;

            const buildingFloors = floors.filter(f => f.building?.id === building.id);
            buildingFloors.forEach(floor => {
              const option = document.createElement('option');
              option.value = floor.id;
              option.textContent = floor.name || `Level ${floor.elevation}`;
              if (floor.id === mapView.currentFloor.id) option.selected = true;
              optgroup.appendChild(option);
            });

            floorSelect.appendChild(optgroup);
          });

          // Add floors without buildings
          const unassignedFloors = floors.filter(f => !f.building);
          if (unassignedFloors.length > 0) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = '📍 Other Floors';
            unassignedFloors.forEach(floor => {
              const option = document.createElement('option');
              option.value = floor.id;
              option.textContent = floor.name || `Level ${floor.elevation}`;
              if (floor.id === mapView.currentFloor.id) option.selected = true;
              optgroup.appendChild(option);
            });
            floorSelect.appendChild(optgroup);
          }
        } else {
          // No buildings - just list floors
          floors.forEach(floor => {
            const option = document.createElement('option');
            option.value = floor.id;
            option.textContent = floor.name || `Level ${floor.elevation}`;
            if (floor.id === mapView.currentFloor.id) option.selected = true;
            floorSelect.appendChild(option);
          });
        }

        floorSelect.addEventListener('change', (e) => mapView.setFloor(e.target.value));
        mapView.on('floor-change', (event) => floorSelect.value = event.floor.id);

        console.log(`✅ Floor selector initialized (${floors.length} floors, ${buildings.length} buildings)`);
      }

      // Smart Labels with Zoom-Based Visibility
      function setupLabels() {
        const spaces = mapData.getByType('space').filter(s => s.name);

        // Keywords for categorization
        const mainAreaKeywords = ['hall', 'entrance', 'lobby', 'atrium', 'plaza', 'pavilion', 'gallery'];
        const amenityKeywords = ['restroom', 'toilet', 'bathroom', 'elevator', 'escalator', 'stairs'];
        const exhibitorKeywords = ['booth', 'exhibit', 'stand', 'kiosk'];

        spaces.forEach(space => {
          const nameLower = space.name.toLowerCase();
          let category = 'booths'; // default
          let rank = 'low';
          let enabled = false; // Start disabled, controlled by zoom

          // Categorize by name and assign rank
          if (mainAreaKeywords.some(keyword => nameLower.includes(keyword))) {
            category = 'mainAreas';
            rank = 'high';
          } else if (amenityKeywords.some(keyword => nameLower.includes(keyword))) {
            category = 'amenities';
            rank = 'medium';
          } else if (space.externalId && space.externalId.match(/^\d+$/)) {
            // Booth number pattern (numeric externalId)
            category = 'booths';
            rank = 'low';
          }

          // Create label with rank
          const label = mapView.Labels.add(space, space.name, {
            interactive: false,
            rank: rank,
            enabled: enabled, // Start disabled
            appearance: {
              textSize: category === 'mainAreas' ? 14 : 12,
              color: category === 'mainAreas' ? '#000' : '#333'
            }
          });

          // Store in appropriate category
          labelCategories[category].push(label);
          allLabels.push(label);
        });

        // Add exhibitor labels (always visible)
        const exhibitors = getAllExhibitors();
        exhibitors.forEach(exhibitor => {
          if (exhibitor.details?.name) {
            const label = mapView.Labels.add(
              exhibitor,
              `${exhibitor.details.externalId} - ${exhibitor.details.name}`,
              {
                interactive: false,
                rank: 'always-visible',
                enabled: true, // Always enabled
                appearance: {
                  textSize: 11,
                  color: '#667eea'
                }
              }
            );
            labelCategories.exhibitors.push(label);
            allLabels.push(label);
          }
        });

        console.log(`✅ Smart labels initialized:
  - ${labelCategories.exhibitors.length} exhibitor labels (always visible)
  - ${labelCategories.mainAreas.length} main area labels (zoom >= ${ZOOM_THRESHOLDS.MAIN_AREAS})
  - ${labelCategories.amenities.length} amenity labels (zoom >= ${ZOOM_THRESHOLDS.AMENITIES})
  - ${labelCategories.booths.length} booth labels (zoom >= ${ZOOM_THRESHOLDS.BOOTHS})`);

        // Set initial visibility based on current zoom
        updateLabelVisibility(currentZoom);
      }

      // Amenities - Icons for restrooms, exits, etc.
      function setupAmenities() {
        const amenities = mapData.getByType('amenity') || [];
        const locations = mapData.getByType('location') || [];

        const amenityIcons = {
          'restroom': '🚻',
          'toilet': '🚻',
          'bathroom': '🚻',
          'wc': '🚻',
          'washroom': '🚻',
          'elevator': '🛗',
          'lift': '🛗',
          'escalator': '🔼',
          'stairs': '🪜',
          'staircase': '🪜',
          'exit': '🚪',
          'emergency-exit': '🚨',
          'parking': '🅿️',
          'atm': '🏧',
          'information': 'ℹ️',
          'info': 'ℹ️',
          'help': 'ℹ️',
          'default': '📍'
        };

        const restroomKeywords = ['restroom', 'toilet', 'bathroom', 'wc', 'washroom'];
        const amenityKeywords = ['elevator', 'lift', 'escalator', 'stairs', 'staircase', 'exit'];
        const roomKeywords = ['room', 'hall', 'conference', 'meeting', 'auditorium', 'theater', 'theatre', 'lounge', 'suite', 'boardroom', 'office', 'balcony'];

        // Restroom category IDs (from location-categories.json)
        const restroomCategoryIds = [
          'lcat_949158e6f42d5a22',  // All Gender Restroom
          'lcat_9ca8623837d4867f'   // Men's Restroom
        ];

        let amenityCount = 0;

        // Method 1: Use Mappedin's amenity data if available
        if (amenities.length > 0) {
          amenities.forEach(amenity => {
            const icon = amenityIcons[amenity.type?.toLowerCase()] || amenityIcons.default;
            const markerHTML = `<div style="background:white;color:#333;padding:6px;border-radius:50%;font-size:20px;box-shadow:0 2px 8px rgba(0,0,0,0.2);">${icon}</div>`;

            const type = amenity.type?.toLowerCase();
            const isRestroom = restroomKeywords.includes(type);

            // Rank: Restrooms = 1 (lowest), Other amenities = 2
            const rank = isRestroom ? 1 : 2;
            const marker = mapView.Markers.add(amenity, markerHTML, { anchor: 'center', rank });

            // Categorize by type
            if (isRestroom) {
              categoryMarkers.restrooms.push(marker);
            } else {
              categoryMarkers.amenities.push(marker);
            }

            amenityCount++;
          });

          console.log(`✅ Added ${amenityCount} amenity icons from Mappedin amenity data`);
        }

        // Method 2: Check locations with categories (for restrooms, etc.)
        let categoryRestroomCount = 0;
        locations.forEach(location => {
          if (location.categories && location.categories.length > 0) {
            const hasRestroomCategory = location.categories.some(catId =>
              restroomCategoryIds.includes(catId)
            );

            if (hasRestroomCategory) {
              const markerHTML = `<div style="background:white;color:#667eea;padding:8px;border-radius:50%;box-shadow:0 2px 8px rgba(0,0,0,0.2);display:flex;align-items:center;justify-content:center;"><i data-lucide="bath" style="width:20px;height:20px;"></i></div>`;

              const marker = mapView.Markers.add(location, markerHTML, {
                anchor: 'center',
                rank: 1,  // Lowest priority - restrooms
                interactive: true
              });

              categoryMarkers.restrooms.push(marker);
              categoryRestroomCount++;
            }
          }
        });

        if (categoryRestroomCount > 0) {
          console.log(`✅ Added ${categoryRestroomCount} restrooms from location categories`);
        }

        // Method 3: Detect rooms/meeting spaces from location names
        let roomCount = 0;
        locations.forEach(location => {
          if (!location.details?.name) return;

          const nameLower = location.details.name.toLowerCase();
          const matchedKeyword = roomKeywords.find(keyword => nameLower.includes(keyword));

          if (matchedKeyword && !location.categories?.length) {  // Don't duplicate restrooms
            const markerHTML = `<div style="background:white;color:#667eea;padding:8px;border-radius:50%;box-shadow:0 2px 8px rgba(0,0,0,0.2);display:flex;align-items:center;justify-content:center;"><i data-lucide="door-open" style="width:20px;height:20px;"></i></div>`;

            const marker = mapView.Markers.add(location, markerHTML, {
              anchor: 'center',
              rank: 2,  // Medium priority - rooms
              interactive: true
            });

            categoryMarkers.rooms.push(marker);
            roomCount++;
          }
        });

        if (roomCount > 0) {
          console.log(`✅ Added ${roomCount} meeting rooms/spaces from location names`);
        }

        // Method 4: Fallback - Detect amenities from space names (if no other data)
        if (amenities.length === 0 && categoryRestroomCount === 0 && roomCount === 0) {
          console.log('ℹ️ No Mappedin amenity/location data - detecting from space names...');

          const allSpaces = mapData.getByType('space');
          const allKeywords = [...restroomKeywords, ...amenityKeywords, ...roomKeywords];

          allSpaces.forEach(space => {
            if (!space.name) return;

            const nameLower = space.name.toLowerCase();
            const matchedKeyword = allKeywords.find(keyword => nameLower.includes(keyword));

            if (matchedKeyword) {
              const icon = amenityIcons[matchedKeyword] || amenityIcons.default;
              const markerHTML = `<div style="background:white;color:#333;padding:6px;border-radius:50%;font-size:20px;box-shadow:0 2px 8px rgba(0,0,0,0.2);">${icon}</div>`;

              // Determine category and rank
              let category;
              let rank;

              if (restroomKeywords.includes(matchedKeyword)) {
                category = 'restrooms';
                rank = 1;  // Lowest priority - restrooms
              } else if (roomKeywords.includes(matchedKeyword)) {
                category = 'rooms';
                rank = 2;  // Medium priority - rooms
              } else {
                category = 'amenities';
                rank = 3;  // Higher priority - elevators, stairs, etc.
              }

              const marker = mapView.Markers.add(space, markerHTML, {
                anchor: 'center',
                rank: rank,
                interactive: false  // Don't interfere with space clicks
              });

              // Add to appropriate category
              if (category && categoryMarkers[category]) {
                categoryMarkers[category].push(marker);
              }
            }
          });
        }

        // Initialize Lucide icons for amenity markers
        if (window.lucide) {
          lucide.createIcons();
        }

        // Summary of all categories detected
        const totalMarkers = categoryMarkers.amenities.length +
                            categoryMarkers.restrooms.length +
                            categoryMarkers.rooms.length;

        console.log(`\n📊 Amenity Detection Summary:`);
        console.log(`   - Amenities: ${categoryMarkers.amenities.length}`);
        console.log(`   - Restrooms: ${categoryMarkers.restrooms.length}`);
        console.log(`   - Rooms: ${categoryMarkers.rooms.length}`);
        console.log(`   - Total: ${totalMarkers} markers`);
      }

      // Exhibitor Markers with Nice Labels (using real location data)
      function setupExhibitors() {
        const exhibitors = getAllExhibitors();

        console.log(`📍 Found ${exhibitors.length} exhibitors with name and booth number`);

        // Log sample exhibitors
        const sample = exhibitors.slice(0, 10).map(loc => ({
          name: loc.details.name,
          booth: loc.details.externalId
        }));
        console.log('📋 Sample exhibitors:', sample);

        // Add markers to locations
        exhibitors.forEach(location => {
          const labelText = `${location.details.externalId} - ${location.details.name}`;

          // Add marker with enhanced styling
          const markerHTML = `
            <div style="
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              padding: 10px 16px;
              border-radius: 20px;
              font-size: 13px;
              font-weight: 600;
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
              cursor: pointer;
              white-space: nowrap;
              border: 2px solid rgba(255,255,255,0.3);
              transition: transform 0.2s;
            " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
              <span style="font-size: 16px; margin-right: 6px;">📍</span>
              <span>${labelText}</span>
            </div>
          `;

          const marker = mapView.Markers.add(location, markerHTML, {
            anchor: 'center',
            rank: 10,
            interactive: true
          });

          marker.addEventListener('click', (e) => {
            e.stopPropagation();
            showCardForLocation(location, true);
          });

          exhibitorMarkers.push({ marker, location });
        });

        console.log(`✅ Added ${exhibitorMarkers.length} exhibitor markers`);
      }

      // Make ALL spaces and objects clickable with hover effects
      function setupSpaceInteractivity() {
        // Make ALL spaces interactive (not just ones with externalId)
        const allSpaces = mapData.getByType('space');

        console.log(`🎨 Making ${allSpaces.length} spaces interactive...`);

        allSpaces.forEach(space => {
          mapView.updateState(space, {
            interactive: true,
            hoverColor: '#667eea',  // Purple hover effect
            color: space.externalId ? '#e0e0e0' : undefined  // Light gray for booths, default for others
          });
        });

        // Make ALL objects interactive (booths, furniture, displays, etc.)
        const allObjects = mapData.getByType('object') || [];
        console.log(`🏢 Making ${allObjects.length} objects interactive...`);

        allObjects.forEach(obj => {
          mapView.updateState(obj, {
            interactive: true,
            hoverColor: '#667eea'
          });

          // Add labels to objects with names (exhibitor objects rank 10 - highest priority)
          if (obj.name) {
            mapView.Labels.add(obj, obj.name, {
              interactive: false,
              rank: 10,  // Rank 10 for exhibitor objects (highest priority)
              appearance: {
                textSize: 11,
                color: '#333'
              }
            });
          }
        });

        // Handle hover events for preview
        mapView.on('hover', (event) => {
          const status = document.getElementById('status');

          if (event?.objects?.length > 0) {
            const obj = event.objects[0];
            status.textContent = `🏢 Hovering: ${obj.name || obj.type || 'Object'}`;
            status.style.background = '#667eea';
          } else if (event?.spaces?.length > 0) {
            const space = event.spaces[0];
            const displayName = space.name || space.externalId || 'Space';
            status.textContent = `🎯 Hovering: ${displayName}`;
            status.style.background = '#667eea';
          } else {
            status.textContent = '👆 Click any booth or object to see details';
            status.style.background = '#333';
          }
        });

        // Handle click events with proper priority
        mapView.on('click', (event) => {
          // Priority 1: Markers (custom UI - they have their own handlers)
          if (event?.markers?.length > 0) {
            return; // Let marker handle it
          }

          // Priority 2: Labels (specific annotations)
          if (event?.labels?.length > 0) {
            console.log('📝 Label clicked:', event.labels[0]);
            // Handle label clicks if needed
            return;
          }

          // Priority 3: Map Objects (doors, windows, furniture, booths, toilets)
          if (event?.objects?.length > 0) {
            const mapObject = event.objects[0];
            console.log('🏢 Object clicked:', mapObject.type, mapObject.name, mapObject);

            // Show object details with navigation
            const cardTitle = document.getElementById('cardTitle');
            const cardBooth = document.getElementById('cardBooth');
            const cardDescription = document.getElementById('cardDescription');
            const cardPrimaryActions = document.getElementById('cardPrimaryActions');
            const cardActions = document.getElementById('cardActions');
            const exhibitorCard = document.getElementById('exhibitorCard');

            cardTitle.textContent = mapObject.name || `${mapObject.type || 'Object'}`;
            cardBooth.textContent = `Type: ${mapObject.type || 'Unknown'}`;
            cardBooth.style.display = 'inline-block';
            cardDescription.innerHTML = `
              <p><strong>Object Type:</strong> ${mapObject.type || 'Unknown'}</p>
              <p><strong>ID:</strong> ${mapObject.id}</p>
              <p>This is a 3D object in the venue. In a conference setting, this could be an exhibitor booth display, furniture, or equipment.</p>
            `;

            // Show Directions button for objects
            cardPrimaryActions.style.display = 'flex';
            cardActions.style.display = 'flex';

            // Setup Directions button
            const directionsBtn = document.getElementById('directionsBtn');
            directionsBtn.onclick = () => {
              const navigationPanel = document.getElementById('navigationPanel');
              navigationPanel.style.display = 'block';

              // Pre-fill "To" field with object
              const navToInput = document.getElementById('navToInput');
              navToInput.value = mapObject.name || mapObject.type || 'Selected Object';
              navToInput.dataset.spaceId = mapObject.id;

              // Re-initialize icons
              if (window.lucide) lucide.createIcons();
            };

            // Hide share button for objects (they don't have booth numbers)
            const shareBtn = document.getElementById('shareBtn');
            shareBtn.style.display = 'none';

            exhibitorCard.classList.add('show');
            mapView.Camera.focusOn(mapObject);

            return;
          }

          // Priority 4: Spaces (floor areas, rooms, booths)
          if (event?.spaces?.length > 0) {
            const space = event.spaces[0];
            showCardForSpace(space);
            return;
          }

          // Priority 5: Empty map click - close card
          const card = document.getElementById('exhibitorCard');
          card.style.display = 'none';
        });

        console.log(`✅ ${allSpaces.length} spaces + ${allObjects.length} objects are now interactive with hover effects`);
      }

      // Show card for a space
      function showCardForSpace(space, showNavigate = false) {
        const cardTitle = document.getElementById('cardTitle');
        const cardBooth = document.getElementById('cardBooth');
        const cardDescription = document.getElementById('cardDescription');
        const cardActions = document.getElementById('cardActions');
        const exhibitorCard = document.getElementById('exhibitorCard');

        // Get exhibitor data if this is a booth
        const exhibitors = getExhibitorsByBooth(space.externalId);

        if (exhibitors.length > 0) {
          // Show exhibitor data
          if (exhibitors.length === 1) {
            // Single exhibitor
            const exhibitor = exhibitors[0];
            cardTitle.textContent = exhibitor.name;
            cardBooth.textContent = `📍 Booth ${space.externalId}`;
            cardBooth.style.display = 'inline-block';
            cardDescription.innerHTML = `
              <div style="margin-bottom: 8px;">
                <strong>🌍 ${exhibitor.country}</strong>
              </div>
              <p>${exhibitor.description}</p>
              ${exhibitor.website ? `<p><a href="${exhibitor.website}" target="_blank" style="color: #667eea;">🌐 Visit Website</a></p>` : ''}
              ${exhibitor.documents ? `<p>📄 Documents: ${exhibitor.documents.join(', ')}</p>` : ''}
            `;
          } else {
            // Multiple co-exhibitors
            cardTitle.textContent = `Booth ${space.externalId} - Co-Exhibitors`;
            cardBooth.textContent = `📍 ${exhibitors.length} Companies`;
            cardBooth.style.display = 'inline-block';
            cardDescription.innerHTML = exhibitors.map(ex => `
              <div style="margin: 16px 0; padding: 12px; border-left: 3px solid #667eea; background: rgba(102, 126, 234, 0.05);">
                <strong style="font-size: 16px;">${ex.name}</strong>
                <div style="margin: 4px 0; color: #666;">🌍 ${ex.country}</div>
                <p style="margin: 8px 0;">${ex.description}</p>
                ${ex.website ? `<a href="${ex.website}" target="_blank" style="color: #667eea;">🌐 Visit Website</a>` : ''}
              </div>
            `).join('');
          }
        } else {
          // No exhibitor data - show space info
          cardTitle.textContent = space.name || 'Unnamed Space';
          if (space.externalId) {
            cardBooth.textContent = `Booth ${space.externalId}`;
            cardBooth.style.display = 'inline-block';
          } else {
            cardBooth.style.display = 'none';
          }
          cardDescription.textContent = space.description || `This is ${space.name || 'a space'} in the venue. ${space.externalId ? 'No exhibitor data available for this booth.' : 'Click booths with numbers to see exhibitor info.'}`;
        }

        document.getElementById('cardCategories').innerHTML = '';

        // Show action buttons for ALL spaces (toilets, rooms, booths, etc.)
        const cardPrimaryActions = document.getElementById('cardPrimaryActions');
        const navigationPanel = document.getElementById('navigationPanel');

        // Always show Directions button, conditionally show Share button
        cardPrimaryActions.style.display = 'flex';
        cardActions.style.display = 'flex';

        // Setup Directions button - shows To/From panel
        const directionsBtn = document.getElementById('directionsBtn');
        directionsBtn.onclick = () => {
          // Show navigation panel
          navigationPanel.style.display = 'block';

          // Hide Directions button (replaced by navigation panel)
          directionsBtn.style.display = 'none';

          // Minimize card content - hide description, show only title
          const cardDescription = document.getElementById('cardDescription');
          const cardTitle = document.getElementById('cardTitle');

          // Store original description and title for restoration
          cardDescription.dataset.originalContent = cardDescription.innerHTML;
          cardTitle.dataset.originalContent = cardTitle.textContent;

          // Hide description
          cardDescription.style.display = 'none';

          // For co-exhibitors, simplify title to show only main booth/parent
          const exhibitors = getExhibitorsByBooth(space.externalId);
          if (exhibitors && exhibitors.length > 1) {
            // Multiple co-exhibitors: Show simplified title with main exhibitor
            cardTitle.textContent = `${exhibitors[0].name} (+ ${exhibitors.length - 1} more)`;
          }

          // Update search input with location name
          const searchInput = document.getElementById('searchInput');
          searchInput.value = space.name || space.externalId || '';

          // Pre-fill "To" field with destination
          const navToInput = document.getElementById('navToInput');
          navToInput.value = space.name || space.externalId || 'Selected Location';
          navToInput.dataset.spaceId = space.id;

          // Enable tap-to-select mode for "From" location
          const navFromInput = document.getElementById('navFromInput');
          const status = document.getElementById('status');

          status.textContent = '👆 Tap on the map to set your starting location';
          status.style.background = '#667eea';
          status.style.display = 'block';

          const selectFromLocation = (event) => {
            if (event.spaces?.length > 0) {
              selectedFromLocation = event.spaces[0];
              navFromInput.value = `📍 ${event.spaces[0].name || event.spaces[0].externalId || 'Location'}`;

              // Auto-trigger directions once both locations are set
              status.textContent = '🧭 Calculating route...';
              status.style.background = '#667eea';

              // Trigger directions automatically
              setTimeout(() => {
                document.getElementById('getDirectionsBtn')?.click();
              }, 300);
            }
            mapView.off('click', selectFromLocation);
          };

          mapView.on('click', selectFromLocation);

          // Re-initialize icons for new elements
          if (window.lucide) lucide.createIcons();
        };

        // Setup share button (only show for spaces with booth numbers)
        const shareBtn = document.getElementById('shareBtn');
        if (space.externalId) {
          shareBtn.style.display = 'flex';
          shareBtn.onclick = () => {
            // Create deep-link URL for sharing via SMS/WhatsApp/etc
            const locationName = space.name || space.externalId || 'Location';
            const shareUrl = `${window.location.origin}${window.location.pathname}?booth=${space.externalId}`;
            const shareText = `Check out ${locationName} at the venue: ${shareUrl}`;

            // Copy share text with URL to clipboard (better for SMS/messaging apps)
            navigator.clipboard.writeText(shareText).then(() => {
              status.textContent = '✅ Share link copied! Paste in SMS/WhatsApp';
              status.style.background = '#28a745';
              status.style.display = 'block';
              setTimeout(() => status.style.display = 'none', 3000);
            }).catch(err => {
              // Fallback - show URL
              status.textContent = `📋 Share: ${shareText}`;
              status.style.background = '#667eea';
              status.style.display = 'block';
              setTimeout(() => status.style.display = 'none', 5000);
            });
          };
        } else {
          shareBtn.style.display = 'none';  // Hide Share button for non-booth spaces
        }

        // Setup website button (placeholder)
        const websiteBtn = document.getElementById('websiteBtn');
        websiteBtn.onclick = () => {
          status.textContent = '🌐 Exhibitor website would open here';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
        };

        exhibitorCard.classList.add('show');
        mapView.Camera.focusOn(space);

        console.log('📋 Showing card for:', space.name || space.externalId || space.id);
      }

      // Show card for a location object (exhibitor)
      function showCardForLocation(location, showNavigate = false) {
        const cardTitle = document.getElementById('cardTitle');
        const cardBooth = document.getElementById('cardBooth');
        const cardDescription = document.getElementById('cardDescription');
        const exhibitorCard = document.getElementById('exhibitorCard');

        // Display exhibitor info from location
        cardTitle.textContent = location.details.name;
        cardBooth.textContent = `📍 Booth ${location.details.externalId}`;
        cardBooth.style.display = 'inline-block';
        cardDescription.innerHTML = `<p>Exhibitor at booth ${location.details.externalId}</p>`;

        // Show action buttons
        const cardPrimaryActions = document.getElementById('cardPrimaryActions');
        const navigationPanel = document.getElementById('navigationPanel');
        cardPrimaryActions.style.display = 'flex';

        // Setup Directions button
        const directionsBtn = document.getElementById('directionsBtn');
        directionsBtn.onclick = () => {
          navigationPanel.style.display = 'block';
          directionsBtn.style.display = 'none';
          cardDescription.style.display = 'none';

          const navToInput = document.getElementById('navToInput');
          navToInput.value = location.details.name;
          navToInput.dataset.locationId = location.id;

          if (window.lucide) lucide.createIcons();
        };

        exhibitorCard.classList.add('show');
        mapView.Camera.focusOn(location);

        console.log('📋 Showing card for exhibitor:', location.details.name);
      }

      // Display turn-by-turn navigation instructions with accessibility awareness
      function displayNavigationInstructions(directions, startSpace, destination) {
        const cardDescription = document.getElementById('cardDescription');
        const accessModeIcon = accessibleMode ? '♿' : '🚶';
        const accessModeText = accessibleMode ? 'Accessible Route' : 'Standard Route';

        // Connection type icons
        const connectionIcons = {
          'elevator': '🛗',
          'escalator': '🔼',
          'stairs': '🪜',
          'ramp': '↗️',
          'door': '🚪',
          'portal': '🌀',
          'shuttle': '🚐',
          'slide': '🛝',
          'security': '🔒'
        };

        let instructionsHTML = `
          <div style="border-top: 2px solid #667eea; padding-top: 12px; margin-top: 12px;">
            <h4 style="margin: 0 0 12px 0; color: #667eea;">
              ${accessModeIcon} ${accessModeText}
            </h4>
            <div style="margin-bottom: 12px;">
              <strong>📏 Distance:</strong> ${Math.round(directions.distance)}m
              (${Math.round(directions.distance * 3.28)}ft)
            </div>
        `;

        if (directions.instructions && directions.instructions.length > 0) {
          instructionsHTML += `
            <div style="margin: 12px 0;">
              <strong>📋 Turn-by-Turn Directions:</strong>
            </div>
            <ol style="margin: 8px 0; padding-left: 20px;">
          `;

          directions.instructions.forEach((instruction, index) => {
            const action = instruction.action?.type || 'proceed';
            const distance = Math.round(instruction.distance || 0);
            const connection = instruction.connection;

            let iconPrefix = '➡️';
            if (connection?.type) {
              iconPrefix = connectionIcons[connection.type] || '➡️';
            } else if (action.includes('left')) {
              iconPrefix = '⬅️';
            } else if (action.includes('right')) {
              iconPrefix = '➡️';
            }

            instructionsHTML += `
              <li style="margin: 8px 0; line-height: 1.4;">
                ${iconPrefix} <strong>${action}</strong>
                ${distance > 0 ? `<br><span style="color: #666; font-size: 12px;">→ ${distance}m ahead</span>` : ''}
                ${connection ? `<br><span style="color: #667eea; font-size: 12px;">→ Use ${connection.type}</span>` : ''}
              </li>
            `;
          });

          instructionsHTML += '</ol>';
        }

        instructionsHTML += `
          <div style="margin-top: 12px; padding: 8px; background: ${accessibleMode ? '#e8f5e9' : '#f5f5f5'}; border-radius: 4px; font-size: 12px;">
            ${accessibleMode ?
              '✅ This route avoids stairs and uses elevators/ramps' :
              'ℹ️ This route may include stairs. Enable ♿ Accessible mode for elevator/ramp routes.'}
          </div>
        </div>
        `;

        cardDescription.innerHTML += instructionsHTML;

        console.log('📍 Navigation instructions displayed in exhibitor card');
      }

      // Navigate to a space (with directions) - Accessible-Aware Navigation
      async function navigateToSpace(destination) {
        try {
          const accessModeText = accessibleMode ? '♿ accessible' : 'standard';
          status.textContent = `🧭 Calculating ${accessModeText} route to ${destination.name || destination.externalId}...`;
          status.style.background = '#667eea';
          status.style.display = 'block';

          // For POC: Use first entrance of a random nearby space as starting point
          // In production: Use BlueDot for actual user location
          const allSpaces = mapData.getByType('space');
          const startSpace = allSpaces[Math.floor(Math.random() * Math.min(10, allSpaces.length))];

          // Get directions using official Mappedin API with accessibility option
          const directions = await mapData.getDirections(startSpace, destination, {
            accessible: accessibleMode  // ✅ Use accessibility state
          });

          if (directions) {
            console.log('📍 Navigation Details:');
            console.log('- Distance:', directions.distance, 'meters');
            console.log('- Accessible mode:', accessibleMode);
            console.log('- Instructions:', directions.instructions?.length || 0, 'steps');

            // Use official Navigation.draw() method (exactly like docs)
            mapView.Navigation.draw(directions, {
              pathOptions: {
                displayArrowsOnPath: true,
                animateArrowsOnPath: true
              }
            });

            // Display turn-by-turn instructions UI
            displayNavigationInstructions(directions, startSpace, destination);

            // Focus on destination
            mapView.Camera.focusOn(destination);

            status.textContent = `✅ Route shown! Distance: ${Math.round(directions.distance)}m`;
            status.style.background = '#28a745';

            // Show clear path button after navigation is drawn
            const clearPathBtn = document.getElementById('clearPathBtn');
            if (clearPathBtn) clearPathBtn.style.display = 'flex';

            setTimeout(() => status.style.display = 'none', 5000);

            console.log('🧭 Navigation route displayed:', {
              from: startSpace.name,
              to: destination.name || destination.externalId,
              distance: directions.distance,
              instructions: directions.instructions?.length || 0
            });

            // Log turn-by-turn instructions if available
            if (directions.instructions) {
              console.log('📋 Turn-by-turn instructions:');
              directions.instructions.forEach((instruction, index) => {
                console.log(`${index + 1}. ${instruction.action?.type} - ${Math.round(instruction.distance)}m`);
              });
            }
          } else {
            status.textContent = '⚠️ Could not calculate route';
            status.style.background = '#ff9800';
            setTimeout(() => status.style.display = 'none', 3000);
          }
        } catch (error) {
          console.error('Navigation error:', error);
          status.textContent = `❌ Navigation error: ${error.message}`;
          status.style.background = '#dc3545';
          setTimeout(() => status.style.display = 'none', 3000);
        }
      }

      // Drop Pin
      function setupDropPin() {
        let dropPinMode = false;
        let dropPinMarker = null;

        document.getElementById('dropPinBtn').addEventListener('click', () => {
          dropPinMode = !dropPinMode;
          document.getElementById('dropPinBtn').classList.toggle('active', dropPinMode);
          status.textContent = dropPinMode ? '🪂 Click map to drop pin!' : 'Drop pin disabled';
          status.style.display = 'block';
          if (!dropPinMode) setTimeout(() => status.style.display = 'none', 2000);
        });

        mapView.on('click', (event) => {
          if (dropPinMode && event.coordinate) {
            if (dropPinMarker) mapView.Markers.remove(dropPinMarker);

            const pinHTML = `<div style="position:relative;width:40px;height:80px;"><div style="position:absolute;top:0;left:50%;transform:translateX(-50%);font-size:32px;animation:parachuteFloat 1.2s ease-out forwards;">🪂</div><div style="position:absolute;bottom:0;left:50%;transform:translateX(-50%);font-size:42px;animation:pinDrop 1.2s ease-out;">📍</div></div>`;

            dropPinMarker = mapView.Markers.add(event.coordinate, pinHTML, { anchor: 'bottom', rank: 5 });
            dropPinMode = false;
            document.getElementById('dropPinBtn').classList.remove('active');
            status.textContent = '📍 Pin dropped!';
            setTimeout(() => status.style.display = 'none', 2000);
          }
        });
      }

      // Accessibility Toggle
      function setupAccessibility() {
        const toggle = document.getElementById('accessibilityToggle');
        const navToggle = document.getElementById('navAccessibleToggle');
        const navStatus = document.getElementById('navAccessibleStatus');

        // Sync both toggles with global state
        function updateAccessibleState(newState) {
          accessibleMode = newState;

          // Update main toggle button
          toggle.classList.toggle('active', accessibleMode);

          // Update navigation panel checkbox
          if (navToggle) {
            navToggle.checked = accessibleMode;
          }

          // Update navigation panel status text
          if (navStatus) {
            if (accessibleMode) {
              navStatus.textContent = '♿ Prefers elevators and ramps';
              navStatus.style.color = '#28a745';
            } else {
              navStatus.textContent = '🚶 All routes (may include stairs)';
              navStatus.style.color = '#666';
            }
          }
        }

        // Main toggle button handler
        toggle.addEventListener('click', () => {
          updateAccessibleState(!accessibleMode);

          if (accessibleMode) {
            status.textContent = '♿ Accessible mode: ON (prefers elevators)';
            console.log('♿ Accessible navigation enabled');
          } else {
            status.textContent = '🚶 Accessible mode: OFF (all routes)';
            console.log('🚶 Standard navigation enabled');
          }

          status.style.background = '#667eea';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
        });

        // Navigation panel checkbox handler
        if (navToggle) {
          navToggle.addEventListener('change', (e) => {
            updateAccessibleState(e.target.checked);

            console.log(`♿ Accessible mode ${accessibleMode ? 'enabled' : 'disabled'} from navigation panel`);
          });
        }

        console.log('✅ Accessibility toggle initialized (default: ON)');
      }


      // Search with Autocomplete
      // Initialize modular search system
      let searchUI;

      function setupSearch() {
        // Create search instance
        const searchInstance = new MappedInSearch(mapData, {
          debounceDelay: 200,
          maxSuggestions: 6,
          searchBoothNumbers: true
        });

        // Create UI manager
        searchUI = new SearchUIManager(searchInstance, mapView, {
          inputSelector: '#searchInput',
          suggestionsSelector: '#searchSuggestions',
          onSelect: (suggestion) => {
            // Suggestion has a 'node' property with the actual map object
            const node = suggestion.node;
            if (!node) {
              console.warn('No node found for suggestion:', suggestion);
              return;
            }

            // Check if it's a location (has details.name) or a space
            if (node.details && node.details.name) {
              showCardForLocation(node, true);
            } else if (node.name || node.id) {
              showCardForSpace(node, true);
            } else {
              console.log('Selected:', node);
            }
          }
        });

        console.log('✅ Modular search initialized (debounced 200ms, Enter key support, booth numbers enabled)');
      }

      // Setup floor and zoom controls
      function setupFloorZoomControls() {
        const floorZoomControls = new FloorZoomControls(mapData, mapView, {
          position: 'top-left',
          showFloorSelector: true,
          showZoomControls: true
        });

        floorZoomControls.init();

        console.log('✅ Floor and zoom controls initialized');
      }

      // NOTE: Search suggestion and selection logic now handled by search-module.js
      // The MappedInSearch and SearchUIManager classes provide:
      // - getSuggestions() - Get autocomplete suggestions
      // - searchBoothNumbers() - Search by externalId
      // - buildSuggestionsHTML() - Build dropdown HTML
      // - focusOnSuggestion() - Focus camera and show card
      //
      // This modular approach makes the search system:
      // - Reusable across HTML and React versions
      // - Easier to test and maintain
      // - More organized and readable

      // Navigation Panel Handlers
      let selectedFromLocation = null;

      // Pin drop for "From" location
      document.getElementById('fromPinIcon')?.addEventListener('click', () => {
        const navFromInput = document.getElementById('navFromInput');
        status.textContent = '📍 Click on map to set starting location';
        status.style.background = '#667eea';
        status.style.display = 'block';

        // Enable one-time click to set from location
        const setFromLocation = (event) => {
          if (event.coordinate) {
            selectedFromLocation = event.coordinate;
            navFromInput.value = `📍 Pin location (${event.coordinate.latitude.toFixed(4)}, ${event.coordinate.longitude.toFixed(4)})`;
            status.textContent = '✅ Starting location set';
            status.style.background = '#28a745';
            setTimeout(() => status.style.display = 'none', 2000);
          } else if (event.spaces?.length > 0) {
            selectedFromLocation = event.spaces[0];
            navFromInput.value = `📍 ${event.spaces[0].name || event.spaces[0].externalId || 'Location'}`;
            status.textContent = '✅ Starting location set';
            status.style.background = '#28a745';
            setTimeout(() => status.style.display = 'none', 2000);
          }
          mapView.off('click', setFromLocation);
        };

        mapView.on('click', setFromLocation);
      });

      // Search functionality for "From" field
      const navFromInput = document.getElementById('navFromInput');
      let fromSearchTimeout;

      navFromInput?.addEventListener('input', async (e) => {
        clearTimeout(fromSearchTimeout);
        const query = e.target.value.trim();

        if (query.length < 2) {
          return;
        }

        // Debounce search
        fromSearchTimeout = setTimeout(async () => {
          try {
            // Use suggest() API for "From" field
            let suggestions = await mapData.Search.suggest(query, {
              enterpriseLocations: { enabled: true },
              places: { enabled: true }
            });

            // Also search booth numbers manually
            const queryUpper = query.toUpperCase();
            const spacesWithIds = mapData.getByType('space').filter(s =>
              s.externalId && s.externalId.toUpperCase().includes(queryUpper)
            );

            // Add booth number matches to suggestions
            if (spacesWithIds.length > 0) {
              const boothSuggestions = spacesWithIds.slice(0, 3).map(space => ({
                name: `Booth ${space.externalId}`,
                value: space.externalId,
                type: 'booth',
                node: space
              }));

              suggestions = [...boothSuggestions, ...(suggestions || [])];
            }

            // If we have results, auto-select first one
            if (suggestions && suggestions.length > 0) {
              const firstResult = suggestions[0];
              if (firstResult.node) {
                selectedFromLocation = firstResult.node;
                navFromInput.value = firstResult.name || firstResult.value || 'Selected Location';
                navFromInput.dataset.spaceId = firstResult.node.id;
              }
            }
          } catch (error) {
            console.error('From field search error:', error);
          }
        }, 300);
      });

      // Get Directions button
      document.getElementById('getDirectionsBtn')?.addEventListener('click', async () => {
        const navToInput = document.getElementById('navToInput');
        const destinationSpaceId = navToInput.dataset.spaceId;

        if (!selectedFromLocation) {
          status.textContent = '⚠️ Please select a starting location';
          status.style.background = '#ff9800';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
          return;
        }

        // Get destination space
        const allSpaces = mapData.getByType('space');
        const destination = allSpaces.find(s => s.id === destinationSpaceId);

        if (!destination) {
          status.textContent = '⚠️ Destination not found';
          status.style.background = '#dc3545';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
          return;
        }

        try {
          // Get directions with accessibility mode
          const directions = await mapData.getDirections(selectedFromLocation, destination, {
            accessible: accessibleMode
          });

          // Draw the path on the map
          mapView.Navigation.draw(directions, {
            pathOptions: {
              nearRadius: 1.5,
              farRadius: 0.8,
              color: '#667eea'
            },
            animatedPathOptions: {
              color: '#667eea',
              animationDuration: 2000
            }
          });

          // Shrink card to compact mode - hide everything except To/From fields
          const exhibitorCard = document.getElementById('exhibitorCard');
          const cardDescription = document.getElementById('cardDescription');
          const cardPrimaryActions = document.getElementById('cardPrimaryActions');

          exhibitorCard.classList.add('compact');
          cardDescription.style.display = 'none';
          cardPrimaryActions.style.display = 'none';

          // Show Clear Path button
          document.getElementById('clearPathBtn').style.display = 'block';

          // Show turn-by-turn section
          const turnByTurnSection = document.getElementById('turnByTurnSection');
          turnByTurnSection.style.display = 'block';

          // Build turn-by-turn instructions
          buildTurnByTurnInstructions(directions);

          // Zoom camera to show entire path
          if (directions.path && directions.path.length > 0) {
            // Get all nodes in the path
            const pathNodes = directions.path;

            // Focus camera on the path to show the entire route
            mapView.Camera.focusOn(pathNodes, {
              minZoom: 1000,
              maxZoom: 3000,
              animationDuration: 800
            });
          }

          // Re-initialize icons
          if (window.lucide) lucide.createIcons();

          status.textContent = `✅ Route calculated (${directions.distance.toFixed(0)}m)`;
          status.style.background = '#28a745';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);

        } catch (error) {
          console.error('Navigation error:', error);
          status.textContent = `❌ Navigation error: ${error.message}`;
          status.style.background = '#dc3545';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 3000);
        }
      });

      // Clear Path button
      document.getElementById('clearPathBtn')?.addEventListener('click', () => {
        mapView.Navigation.clear();
        document.getElementById('clearPathBtn').style.display = 'none';
        document.getElementById('turnByTurnSection').style.display = 'none';

        // Restore card to full size
        const exhibitorCard = document.getElementById('exhibitorCard');
        exhibitorCard.classList.remove('compact');

        // Restore Directions button and description visibility
        document.getElementById('directionsBtn').style.display = 'flex';
        document.getElementById('cardPrimaryActions').style.display = 'flex';

        const cardDescription = document.getElementById('cardDescription');
        const cardTitle = document.getElementById('cardTitle');

        cardDescription.style.display = 'block';

        // Restore original title and description if they were modified
        if (cardTitle.dataset.originalContent) {
          cardTitle.textContent = cardTitle.dataset.originalContent;
          delete cardTitle.dataset.originalContent;
        }
        if (cardDescription.dataset.originalContent) {
          cardDescription.innerHTML = cardDescription.dataset.originalContent;
          delete cardDescription.dataset.originalContent;
        }

        status.textContent = '✅ Path cleared';
        status.style.background = '#28a745';
        status.style.display = 'block';
        setTimeout(() => status.style.display = 'none', 2000);
      });

      // Turn-by-Turn toggle
      document.getElementById('toggleTurnByTurn')?.addEventListener('click', () => {
        const content = document.getElementById('turnByTurnContent');
        const chevron = document.getElementById('turnByTurnChevron');

        if (content.style.display === 'none') {
          content.style.display = 'block';
          chevron.style.transform = 'rotate(180deg)';
        } else {
          content.style.display = 'none';
          chevron.style.transform = 'rotate(0deg)';
        }
      });

      // Build turn-by-turn instructions using DirectionsCard component
      function buildTurnByTurnInstructions(directions) {
        const turnByTurnContent = document.getElementById('turnByTurnContent');

        // Use the DirectionsCard component for improved UI
        const directionsCard = new DirectionsCard({
          accessibleMode: accessibleMode,
          onStepClick: (instruction, index) => {
            // Focus camera on the instruction location
            if (instruction.coordinate) {
              mapView.Camera.focusOn({
                nodes: [instruction],
                minZoom: 800,
                maxZoom: 1500,
                animationDuration: 600
              });
            }
          }
        });

        // Render just the instructions section (not the full card)
        const instructionsHTML = directionsCard.buildRouteInfo(directions,
          accessibleMode ? '♿' : '🚶',
          accessibleMode ? 'Accessible Route' : 'Standard Route'
        ) + directionsCard.buildInstructions(directions.instructions);

        turnByTurnContent.innerHTML = instructionsHTML;

        // Attach click handlers to steps
        const steps = turnByTurnContent.querySelectorAll('.step');
        steps.forEach((step, index) => {
          step.addEventListener('click', () => {
            const instruction = directions.instructions[index];

            // Visual feedback - highlight clicked step
            steps.forEach(s => s.classList.remove('step--active'));
            step.classList.add('step--active');

            if (instruction.coordinate) {
              // Focus camera on this step's location
              console.log(`📍 Focusing on step ${index + 1}:`, instruction);
              mapView.Camera.set({
                center: { x: instruction.coordinate[0], y: instruction.coordinate[1] },
                zoom: 1200,
                tilt: 0,
                rotation: 0,
                animationDuration: 600
              });
            } else {
              console.warn(`⚠️ Step ${index + 1} has no coordinate`, instruction);
            }
          });
        });
      }

      // Floating Filter Buttons
      console.log('🔧 Setting up floating filter buttons...');

      // Amenities Toggle (includes restrooms and rooms)
      const amenitiesBtn = document.getElementById('amenitiesToggle');
      console.log('Amenities button found:', amenitiesBtn);

      if (amenitiesBtn) {
        amenitiesBtn.addEventListener('click', function() {
          console.log('🎯 Amenities button clicked!');
          this.classList.toggle('active');
          const isActive = this.classList.contains('active');

          // Toggle all amenity categories
          categoryMarkers.amenities.forEach(marker => {
            marker.visible = isActive;
          });
          categoryMarkers.restrooms.forEach(marker => {
            marker.visible = isActive;
          });
          categoryMarkers.rooms.forEach(marker => {
            marker.visible = isActive;
          });

          const totalAmenities = categoryMarkers.amenities.length +
                                categoryMarkers.restrooms.length +
                                categoryMarkers.rooms.length;

          console.log(`${isActive ? '✅ Showing' : '❌ Hiding'} amenities (${totalAmenities} total: ${categoryMarkers.amenities.length} general, ${categoryMarkers.restrooms.length} restrooms, ${categoryMarkers.rooms.length} rooms)`);
        });
      }

      // Exhibitors Toggle
      const exhibitorsBtn = document.getElementById('exhibitorsToggle');
      console.log('Exhibitors button found:', exhibitorsBtn);

      if (exhibitorsBtn) {
        exhibitorsBtn.addEventListener('click', function() {
          console.log('🎯 Exhibitors button clicked!');
          this.classList.toggle('active');
          const isActive = this.classList.contains('active');

          // Toggle all exhibitor markers
          exhibitorMarkers.forEach(marker => {
            marker.visible = isActive;
          });

          console.log(`${isActive ? '✅ Showing' : '❌ Hiding'} exhibitors (${exhibitorMarkers.length} markers)`);
        });
      }

      // Close card
      document.getElementById('closeCard')?.addEventListener('click', () => {
        document.getElementById('exhibitorCard').classList.remove('show');
        document.getElementById('navigationPanel').style.display = 'none';

        // Restore Directions button and description visibility
        document.getElementById('directionsBtn').style.display = 'flex';
        const cardDescription = document.getElementById('cardDescription');
        const cardTitle = document.getElementById('cardTitle');

        cardDescription.style.display = 'block';

        // Restore original title and description if they were modified
        if (cardTitle.dataset.originalContent) {
          cardTitle.textContent = cardTitle.dataset.originalContent;
          delete cardTitle.dataset.originalContent;
        }
        if (cardDescription.dataset.originalContent) {
          cardDescription.innerHTML = cardDescription.dataset.originalContent;
          delete cardDescription.dataset.originalContent;
        }
      });
    });
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body, html {
      width: 100%;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      position: fixed;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-x pan-y;
    }

    /* Prevent pull-to-refresh on mobile */
    body {
      overscroll-behavior: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }

    /* Touch-friendly interactive elements */
    button, a, input, select, .clickable {
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
      touch-action: manipulation;
      min-height: 44px; /* iOS Human Interface Guidelines minimum */
      min-width: 44px;
    }

    /* Prevent text selection on touch */
    * {
      -webkit-user-select: none;
      user-select: none;
    }

    /* Allow text selection in inputs */
    input, textarea {
      -webkit-user-select: text;
      user-select: text;
    }

    #mappedin-map {
      width: 100%;
      height: 100%;
      touch-action: pan-x pan-y pinch-zoom;
    }

    /* Search Bar - Always Visible */
    .search-container {
      position: absolute;
      top: 16px;
      left: 16px;
      z-index: 100;
      max-width: 360px;
      width: calc(100% - 32px);
    }

    #searchInput {
      width: 100%;
      padding: 12px 16px;
      border: none;
      border-radius: 24px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.2);
      font-size: 14px;
      outline: none;
    }

    /* Search Suggestions Dropdown */
    .search-suggestions {
      display: none;
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
    }

    .search-suggestion {
      padding: 14px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      transition: background 0.15s;
      -webkit-tap-highlight-color: transparent;
      min-height: 60px;
      display: flex;
      align-items: center;
      user-select: none;
      -webkit-user-select: none;
    }

    .search-suggestion:last-child {
      border-bottom: none;
    }

    .search-suggestion:hover,
    .search-suggestion:active {
      background: #f8f9fa;
    }

    /* Better touch feedback for mobile */
    @media (hover: none) {
      .search-suggestion:active {
        background: #e8eaed;
        transform: scale(0.98);
      }
    }

    .suggestion-name {
      font-size: 14px;
      font-weight: 500;
      color: #333;
      margin-bottom: 4px;
    }

    .suggestion-type {
      font-size: 12px;
      color: #999;
    }

    #status {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 12px 24px;
      border-radius: 24px;
      z-index: 100;
      font-size: 14px;
    }

    /* Right Controls */
    .controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 100;
    }

    /* Floor Selector */
    .floor-selector {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.15);
      padding: 12px;
      min-width: 150px;
      display: none;
    }

    .floor-label {
      font-size: 11px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .floor-selector select {
      width: 100%;
      padding: 8px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: 13px;
      outline: none;
      cursor: pointer;
    }

    /* Control Group */
    .control-group {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.15);
      padding: 12px;
    }

    .control-title {
      font-size: 11px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .toggle-btn {
      width: 100%;
      padding: 12px 14px;
      min-height: 44px;
      border: none;
      border-radius: 8px;
      background: #f0f0f0;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #333;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .toggle-btn:last-child {
      margin-bottom: 0;
    }

    .toggle-btn:hover,
    .toggle-btn:active {
      background: #e0e0e0;
    }

    .toggle-btn.active {
      background: #667eea;
      color: white;
    }

    .toggle-btn.active:hover,
    .toggle-btn.active:active {
      background: #5568d3;
    }

    /* Floating Toggle Buttons */
    .floating-toggle {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      min-width: 44px;
      min-height: 44px;
      background: white;
      border: 2px solid #ddd;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      pointer-events: auto;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
    }

    .floating-toggle:hover,
    .floating-toggle:active {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      border-color: #667eea;
    }

    .floating-toggle.active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    .floating-toggle.active:hover,
    .floating-toggle.active:active {
      background: #5568d3;
    }

    /* Better touch feedback */
    @media (hover: none) {
      .floating-toggle:active {
        transform: scale(0.95);
      }
    }

    /* Exhibitor Card */
    #exhibitorCard {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%) translateY(400px);
      width: calc(100% - 32px);
      max-width: 420px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.2);
      padding: 16px;
      z-index: 200;
      transition: transform 0.3s ease-out, padding 0.3s ease-out;
    }

    #exhibitorCard.compact {
      padding: 12px;
    }

    #exhibitorCard.show {
      transform: translateX(-50%) translateY(0);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .card-title {
      font-size: 16px;
      font-weight: 600;
      color: #1a1a1a;
      line-height: 1.3;
    }

    .card-booth {
      display: inline-block;
      background: #667eea;
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      margin-top: 4px;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 28px;
      cursor: pointer;
      color: #999;
      padding: 8px;
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      border-radius: 50%;
      transition: background 0.2s;
    }

    .close-btn:hover,
    .close-btn:active {
      background: #f0f0f0;
      color: #333;
    }

    .card-description {
      color: #666;
      font-size: 14px;
      margin-bottom: 12px;
    }

    .card-categories {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .card-actions {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    .action-btn {
      flex: 1;
      padding: 12px 16px;
      min-height: 44px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .action-btn:hover,
    .action-btn:active {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .action-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .action-btn.secondary {
      background: #f0f0f0;
      color: #333;
    }

    /* Primary Action Buttons - Wide Outline Style */
    .card-primary-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e0e0e0;
    }

    .action-btn-wide {
      width: 100%;
      padding: 14px 20px;
      min-height: 48px;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
    }

    .action-btn-wide.outline {
      background: transparent;
      border: 2px solid #667eea;
      color: #667eea;
    }

    .action-btn-wide.outline:hover,
    .action-btn-wide.outline:active {
      background: #667eea;
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    /* Mobile-specific touch feedback */
    @media (hover: none) {
      .action-btn-wide.outline:active {
        transform: scale(0.98);
      }
    }

    /* Hide Mappedin Watermark (WARNING: May violate terms of service) */
    /* Only use if you have proper licensing/permission from Mappedin */
    /*
    .mappedin-watermark,
    [class*="watermark"],
    [class*="attribution"] {
      display: none !important;
      opacity: 0 !important;
      visibility: hidden !important;
    }
    */

    @keyframes parachuteFloat {
      0% { transform: translateX(-50%) translateY(-120px); opacity: 0; }
      40% { opacity: 1; }
      70% { opacity: 1; }
      100% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
    }

    @keyframes pinDrop {
      0% { transform: translateX(-50%) translateY(-120px); opacity: 0; }
      60% { transform: translateX(-50%) translateY(5px); }
      75% { transform: translateX(-50%) translateY(-3px); }
      100% { transform: translateX(-50%) translateY(0); opacity: 1; }
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      .search-container {
        top: 12px;
        left: 12px;
        width: calc(100% - 24px);
        max-width: none;
      }

      #searchInput {
        padding: 10px 14px;
        padding-left: 40px;
        font-size: 14px;
      }

      #exhibitorCard {
        bottom: 12px;
        width: calc(100% - 24px);
        max-width: none;
        padding: 14px;
        border-radius: 10px;
      }

      #exhibitorCard.compact {
        padding: 10px;
      }

      .card-title {
        font-size: 15px;
      }

      .card-booth {
        font-size: 11px;
        padding: 3px 8px;
      }

      #navigationPanel {
        padding: 10px;
      }

      .action-btn-wide {
        padding: 10px 14px;
        font-size: 13px;
      }

      .controls {
        right: 12px;
        top: 12px;
      }

      .floor-selector select {
        font-size: 13px;
        padding: 6px 10px;
      }

      .toggle-btn {
        font-size: 13px;
        padding: 8px 12px;
      }
    }

    /* iPhone and small mobile devices */
    @media (max-width: 390px) {
      .search-container {
        top: 10px;
        left: 10px;
        width: calc(100% - 20px);
      }

      #searchInput {
        font-size: 13px;
      }

      #exhibitorCard {
        bottom: 10px;
        width: calc(100% - 20px);
        padding: 12px;
      }

      .card-title {
        font-size: 14px;
      }

      .floating-toggle {
        padding: 8px 12px;
      }

      .floating-toggle i {
        width: 20px !important;
        height: 20px !important;
      }

      .floating-toggle span {
        font-size: 11px !important;
      }
    }
  </style>
</head>
<body>
  <div id="mappedin-map"></div>

  <!-- Search Bar - Always Visible -->
  <div class="search-container">
    <div style="position: relative;">
      <i data-lucide="search" style="position: absolute; left: 16px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; color: #999;"></i>
      <input type="text" id="searchInput" placeholder="Search exhibitors or booth number..." style="padding-left: 44px;">

      <!-- Search Suggestions Dropdown -->
      <div id="searchSuggestions" class="search-suggestions"></div>
    </div>
  </div>

  <div id="status">Initializing...</div>

  <!-- Right Side Controls -->
  <div class="controls">
    <!-- Floor Selector -->
    <div class="floor-selector" id="floorSelectorContainer">
      <div class="floor-label">Floor</div>
      <select id="floorSelect">
        <option>Loading...</option>
      </select>
    </div>

    <!-- Controls Group -->
    <div class="control-group">
      <div class="control-title">Controls</div>
      <button class="toggle-btn active" id="accessibilityToggle">
        <i data-lucide="accessibility" style="width: 18px; height: 18px;"></i>
        <span>Accessible</span>
      </button>
      <button class="toggle-btn" id="dropPinBtn">
        <i data-lucide="map-pin" style="width: 18px; height: 18px;"></i>
        <span>Drop Pin</span>
      </button>
    </div>

    <!-- Floating Filter Buttons (Bottom Center) -->
    <div style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 16px; z-index: 100; pointer-events: none;">
      <!-- Amenities Toggle -->
      <button id="amenitiesToggle" class="floating-toggle" title="Toggle Amenities">
        <i data-lucide="building-2" style="width: 32px; height: 32px;"></i>
      </button>

      <!-- Exhibitors Toggle -->
      <button id="exhibitorsToggle" class="floating-toggle active" title="Toggle Exhibitors">
        <i data-lucide="store" style="width: 32px; height: 32px;"></i>
      </button>
    </div>
  </div>

  <!-- Exhibitor Card -->
  <div id="exhibitorCard">
    <div class="card-header">
      <div>
        <div class="card-title" id="cardTitle">Exhibitor</div>
        <div class="card-booth" id="cardBooth">Booth</div>
      </div>
      <button class="close-btn" id="closeCard">×</button>
    </div>

    <!-- Primary Actions at Top -->
    <div class="card-primary-actions" id="cardPrimaryActions" style="display:none;">
      <button class="action-btn-wide outline" id="directionsBtn">
        <i data-lucide="navigation" style="width: 18px; height: 18px; margin-right: 8px;"></i>
        Directions
      </button>
      <button class="action-btn-wide outline" id="shareBtn">
        <i data-lucide="share-2" style="width: 18px; height: 18px; margin-right: 8px;"></i>
        Share URL
      </button>
    </div>

    <!-- Navigation Panel (shown when Directions clicked) -->
    <div id="navigationPanel" style="display:none; margin-bottom: 12px; padding: 12px; background: #f8f9fa; border-radius: 8px;">
      <!-- To/From Fields -->
      <div style="margin-bottom: 10px;">
        <label style="display: block; font-size: 11px; color: #666; margin-bottom: 4px; font-weight: 500;">To:</label>
        <input type="text" id="navToInput" readonly style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; background: #e9ecef; color: #333; font-size: 13px;">
      </div>

      <div style="margin-bottom: 10px;">
        <label style="display: block; font-size: 11px; color: #666; margin-bottom: 4px; font-weight: 500;">From:</label>
        <div style="position: relative;">
          <i data-lucide="search" style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); width: 16px; height: 16px; color: #999;"></i>
          <input type="text" id="navFromInput" placeholder="Search location or drop pin..." style="width: 100%; padding: 10px 36px 10px 36px; border: 1px solid #ddd; border-radius: 8px; font-size: 13px;">
          <i data-lucide="map-pin" id="fromPinIcon" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); width: 16px; height: 16px; color: #667eea; cursor: pointer;" title="Drop pin on map"></i>
        </div>
      </div>

      <!-- Accessible Mode Toggle -->
      <div style="margin-bottom: 10px; padding: 8px 10px; background: white; border-radius: 6px; border: 1px solid #ddd;">
        <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none;">
          <div style="display: flex; align-items: center; gap: 6px;">
            <i data-lucide="accessibility" style="width: 16px; height: 16px; color: #667eea;"></i>
            <span style="font-size: 13px; color: #333;">Accessible Route</span>
          </div>
          <input type="checkbox" id="navAccessibleToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
        </label>
        <div id="navAccessibleStatus" style="margin-top: 4px; font-size: 11px; color: #28a745;">
          ♿ Prefers elevators and ramps
        </div>
      </div>

      <!-- Get Directions Button -->
      <button id="getDirectionsBtn" class="action-btn-wide outline" style="margin-bottom: 0; padding: 10px 16px; font-size: 14px;">
        <i data-lucide="route" style="width: 16px; height: 16px; margin-right: 6px;"></i>
        Get Directions
      </button>

      <!-- Clear Path Button -->
      <button id="clearPathBtn" style="display:none; width: 100%; padding: 10px; border: 1px solid #dc3545; background: white; color: #dc3545; border-radius: 6px; cursor: pointer; font-size: 14px;">
        <i data-lucide="x" style="width: 16px; height: 16px; margin-right: 6px;"></i>
        Clear Path
      </button>

      <!-- Turn-by-Turn Collapsible -->
      <div id="turnByTurnSection" style="display:none; margin-top: 12px;">
        <button id="toggleTurnByTurn" style="width: 100%; padding: 10px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; font-size: 14px; color: #333;">
          <span>
            <i data-lucide="list" style="width: 16px; height: 16px; margin-right: 6px;"></i>
            Turn-by-Turn Instructions
          </span>
          <i data-lucide="chevron-down" id="turnByTurnChevron" style="width: 16px; height: 16px;"></i>
        </button>
        <div id="turnByTurnContent" style="display:none; margin-top: 8px; padding: 12px; background: white; border-radius: 6px; border: 1px solid #ddd; max-height: 300px; overflow-y: auto;">
          <!-- Instructions will be inserted here -->
        </div>
      </div>
    </div>

    <div class="card-description" id="cardDescription">Description...</div>
    <div class="card-categories" id="cardCategories"></div>

    <!-- Secondary Actions at Bottom -->
    <div class="card-actions" id="cardActions" style="display:none;">
      <button class="action-btn secondary" id="websiteBtn">
        <i data-lucide="external-link" style="width: 16px; height: 16px; margin-right: 6px;"></i>
        Visit Website
      </button>
    </div>
  </div>

  <!-- Version Switcher Pill Button -->
  <a
    href="./react-app/"
    class="version-switcher"
    title="Switch to React + TypeScript version"
  >
    <i data-lucide="code-2" style="width: 16px; height: 16px;"></i>
    <span>React Version</span>
  </a>

  <style>
    .version-switcher {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 10000;

      display: flex;
      align-items: center;
      gap: 8px;

      padding: 10px 16px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border: 1px solid #e5e6ea;
      border-radius: 999px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);

      font-family: Inter, system-ui, -apple-system, sans-serif;
      font-size: 13px;
      font-weight: 600;
      color: #667eea;
      text-decoration: none;

      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
    }

    .version-switcher:hover {
      background: rgba(102, 126, 234, 0.1);
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(102, 126, 234, 0.2);
    }

    .version-switcher:active {
      transform: translateY(0);
    }

    /* Dark mode */
    @media (prefers-color-scheme: dark) {
      .version-switcher {
        background: rgba(28, 28, 30, 0.95);
        border-color: #38383a;
        color: #5a8eef;
      }

      .version-switcher:hover {
        background: rgba(90, 142, 239, 0.1);
        border-color: #5a8eef;
        box-shadow: 0 6px 16px rgba(90, 142, 239, 0.2);
      }
    }

    /* Mobile */
    @media (max-width: 768px) {
      .version-switcher {
        bottom: 12px;
        right: 12px;
        font-size: 12px;
        padding: 8px 12px;
      }

      .version-switcher span {
        display: none;
      }

      .version-switcher i {
        margin: 0;
      }
    }
  </style>

  <!-- Initialize Lucide Icons -->
  <script>
    // Initialize all Lucide icons after DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      if (window.lucide) {
        lucide.createIcons();
        console.log('✅ Lucide icons initialized');
      }
    });
  </script>
</body>
</html>
