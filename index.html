<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">

  <!-- Touch optimization for iframe embedding -->
  <meta name="touch-action" content="pan-x pan-y">

  <title>Mappedin Conference POC - Production Ready</title>

  <!-- Lucide Icons - Modern outline icons -->
  <script src="https://unpkg.com/lucide@latest"></script>

  <!-- Component Styles -->
  <link rel="stylesheet" href="/css/loading-states.css">
  <link rel="stylesheet" href="/css/directions-card.css">

  <!-- Modular Components -->
  <script src="/js/search-module.js"></script>
  <script src="/js/directions-card.js"></script>

  <script type="module">
    // This will use the local npm packages - CORRECT PATTERN
    import { getMapData, show3dMap } from '@mappedin/mappedin-js';
    import '@mappedin/mappedin-js/lib/index.css';

    window.addEventListener('DOMContentLoaded', async () => {
      const status = document.getElementById('status');
      let mapView, mapData;
      let allLabels = [];
      let labelsVisible = true;
      let exhibitorMarkers = [];
      let accessibleMode = true;  // Default accessible mode ON
      let categoryMarkers = {
        amenities: [],
        restrooms: [],
        rooms: []
      };

      // Label categories with zoom thresholds for progressive disclosure
      let labelCategories = {
        exhibitors: [],      // Always visible (rank: 'always-visible')
        mainAreas: [],       // Visible at zoom >= 18 (rank: 'high')
        amenities: [],       // Visible at zoom >= 20 (rank: 'medium')
        booths: []          // Visible at zoom >= 22 (rank: 'low')
      };

      // Zoom thresholds for label visibility
      const ZOOM_THRESHOLDS = {
        EXHIBITORS: 0,     // Always visible
        MAIN_AREAS: 18,    // Major halls, entrances
        AMENITIES: 20,     // Restrooms, elevators
        BOOTHS: 22         // Individual booth numbers
      };

      let currentZoom = 19; // Track current zoom level

      // Get location by booth number (externalId)
      function getLocationByBooth(boothNumber) {
        if (!boothNumber || !mapData) return null;
        const locations = mapData.getByType('location');
        return locations.find(loc =>
          loc.details?.externalId?.toUpperCase() === boothNumber.toUpperCase()
        );
      }

      // Get all exhibitor locations (locations with both name and externalId)
      function getAllExhibitors() {
        if (!mapData) return [];
        const locations = mapData.getByType('location');
        return locations.filter(loc =>
          loc.details?.name && loc.details?.externalId
        );
      }

      // Get exhibitor data for a booth (returns array for consistency with old co-exhibitor pattern)
      function getExhibitorsByBooth(boothNumber) {
        const location = getLocationByBooth(boothNumber);
        if (!location || !location.details?.name) return [];

        // Return as array with location data
        return [{
          name: location.details.name,
          booth: location.details.externalId,
          location: location  // Include full location object for geometry access
        }];
      }

      try {
        status.textContent = 'Loading map data...';

        // Step 1: Fetch map data from Mappedin API with search enabled
        mapData = await getMapData({
          mapId: '688ea50e362b1d000ba0822b',
          key: 'mik_iND9Ra87M1Ca4DD444be4063d',
          secret: 'mis_esa0RDim6GGkbO2f7m6jNca0ADvFcZc8IzigafkC2dq85341024',
          search: { enabled: true }  // Enable built-in Mappedin search
        });

        status.textContent = 'Rendering 3D map...';

        // Step 2: Initialize 3D map view
        mapView = await show3dMap(
          document.getElementById('mappedin-map'),
          mapData
        );

        // Use the mapData we already fetched (not mapView.mapData)
        const spaces = mapData.getByType('space');

        // Log what data we have for debugging
        console.log('📊 Map Data Summary:');
        console.log('- Total spaces:', spaces.length);
        console.log('- Spaces with externalId:', spaces.filter(s => s.externalId).length);
        console.log('- Sample space data:', spaces[0]);

        // Investigate space properties for restroom detection
        console.log('\n🔍 Investigating space properties for amenity detection:');

        // Check for spaces with specific types
        const spaceTypes = [...new Set(spaces.map(s => s.type).filter(Boolean))];
        console.log('- Unique space types:', spaceTypes);

        // Check for category property
        const spacesWithCategory = spaces.filter(s => s.category);
        console.log('- Spaces with category:', spacesWithCategory.length);
        if (spacesWithCategory.length > 0) {
          const categories = [...new Set(spacesWithCategory.map(s => s.category))];
          console.log('- Unique categories:', categories);
          console.log('- Sample space with category:', spacesWithCategory[0]);
        }

        // Check for tags
        const spacesWithTags = spaces.filter(s => s.tags && s.tags.length > 0);
        console.log('- Spaces with tags:', spacesWithTags.length);
        if (spacesWithTags.length > 0) {
          const allTags = [...new Set(spacesWithTags.flatMap(s => s.tags || []))];
          console.log('- Unique tags:', allTags);
          console.log('- Sample space with tags:', spacesWithTags[0]);
        }

        // Check space names for patterns
        const namedSpaces = spaces.filter(s => s.name);
        console.log('- Spaces with names:', namedSpaces.length);
        const uniqueNames = [...new Set(namedSpaces.map(s => s.name))].slice(0, 20);
        console.log('- Sample space names (first 20):', uniqueNames);

        // Check for specific category that might indicate restrooms
        const roomCategorySpaces = spaces.filter(s => s.category === 'room');
        console.log('- Spaces with category="room":', roomCategorySpaces.length);
        if (roomCategorySpaces.length > 0) {
          console.log('- Sample room category space:', roomCategorySpaces[0]);
          console.log('- First 10 room names:', roomCategorySpaces.slice(0, 10).map(s => s.name || s.externalId));
        }

        // Deep dive: show ALL properties of first space for analysis
        if (spaces.length > 0) {
          console.log('\n🔬 Deep Analysis - ALL properties of first space:');
          const firstSpace = spaces[0];
          console.log('Full space object:', firstSpace);
          console.log('All enumerable properties:', Object.keys(firstSpace));
          console.log('All property values:');
          Object.keys(firstSpace).forEach(key => {
            console.log(`  - ${key}:`, firstSpace[key]);
          });
        }

        // Check for amenities
        const amenities = mapData.getByType('amenity') || [];
        console.log('- Amenities:', amenities.length);
        if (amenities.length > 0) console.log('- Sample amenity:', amenities[0]);

        status.textContent = `✅ Success! Loaded ${spaces.length} spaces`;
        status.style.background = '#28a745';
        status.style.color = 'white';

        setTimeout(() => status.style.display = 'none', 3000);

        // Setup all features
        setupFloorSelector();
        setupLabels();
        setupAmenities();
        setupExhibitors();
        setupSpaceInteractivity();
        setupAccessibility();
        setupDropPin();

        // Setup camera event listener for zoom-based label visibility
        setupCameraZoomListener();

        // Setup search (must be after card functions are defined)
        setupSearch();

        // Final comprehensive Lucide icon initialization after ALL setup complete
        setTimeout(() => {
          if (window.lucide) {
            lucide.createIcons();
            console.log('✅ All Lucide icons initialized (comprehensive final pass)');

            // Check if icons actually rendered
            const lucideIcons = document.querySelectorAll('[data-lucide]');
            console.log(`🔍 Found ${lucideIcons.length} Lucide icon elements in DOM`);

            // Log first few to debug
            if (lucideIcons.length > 0) {
              console.log('📍 Sample icon elements:', Array.from(lucideIcons).slice(0, 3).map(el => ({
                name: el.getAttribute('data-lucide'),
                parent: el.parentElement?.className || 'unknown'
              })));
            }
          }
        }, 500);

        // ============================================
        // DEVELOPER DEBUG PANEL - Real-time Monitoring
        // ============================================
        const devPanel = document.getElementById('devDebugPanel');
        const devToggle = document.getElementById('devDebugToggle');
        const devPanelClose = document.getElementById('devPanelClose');
        const devLogContent = document.getElementById('devLogContent');
        let devLogs = [];

        // Toggle panel visibility
        devToggle.addEventListener('click', () => {
          const isVisible = devPanel.style.display === 'block';
          devPanel.style.display = isVisible ? 'none' : 'block';
          devToggle.style.display = isVisible ? 'block' : 'none';

          if (!isVisible) {
            updateDevStats();
            devLog('🛠️ Debug panel opened');
          }
        });

        devPanelClose.addEventListener('click', () => {
          devPanel.style.display = 'none';
          devToggle.style.display = 'block';
        });

        // Log function for activity
        function devLog(message) {
          const timestamp = new Date().toLocaleTimeString();
          devLogs.unshift(`[${timestamp}] ${message}`);
          if (devLogs.length > 50) devLogs.pop(); // Keep last 50
          devLogContent.innerHTML = devLogs.join('<br>');
        }

        // Update stats
        function updateDevStats() {
          // Zoom level
          const zoom = mapView?.Camera?.zoom || 0;
          document.querySelector('#devZoom span').textContent = zoom.toFixed(2);

          // Marker counts
          document.querySelector('#devExhibitors span').textContent = exhibitorMarkers.length;
          document.querySelector('#devAmenities span').textContent = categoryMarkers.amenities.length;
          document.querySelector('#devRestrooms span').textContent = categoryMarkers.restrooms.length;
          document.querySelector('#devRooms span').textContent = categoryMarkers.rooms.length;

          // Floor
          const floor = mapView?.currentFloor?.name || 'Unknown';
          document.querySelector('#devFloor span').textContent = floor;

          // Environment
          document.querySelector('#devViewport span').textContent = `${window.innerWidth}×${window.innerHeight}`;
          document.querySelector('#devIframe span').textContent = window.self !== window.top ? 'YES' : 'NO';
          document.querySelector('#devTouch span').textContent = 'ontouchstart' in window ? 'YES' : 'NO';
          document.querySelector('#devLucide span').textContent = window.lucide ? 'YES' : 'NO';
        }

        // Listen to map clicks and update debug info
        mapView.on('click', (event) => {
          let clickInfo = 'Click detected: ';

          if (event?.markers?.length > 0) {
            const marker = event.markers[0];
            if (marker._amenityData) {
              clickInfo += `Amenity (${marker._amenityData.amenityName})`;
              devLog(`🖱️ Clicked amenity: ${marker._amenityData.amenityName}`);
            } else if (marker._exhibitorLocation) {
              clickInfo += `Exhibitor (${marker._exhibitorLocation.details.name})`;
              devLog(`🖱️ Clicked exhibitor: ${marker._exhibitorLocation.details.name}`);
            } else {
              clickInfo += 'Unknown marker';
              devLog('🖱️ Clicked unknown marker');
            }
          } else if (event?.spaces?.length > 0) {
            const space = event.spaces[0];
            clickInfo += `Space (${space.name || space.externalId || 'Unnamed'})`;
            devLog(`🖱️ Clicked space: ${space.name || space.externalId || 'ID:'+space.id}`);
          } else if (event?.objects?.length > 0) {
            const obj = event.objects[0];
            clickInfo += `Object (${obj.name || obj.type || 'Unknown'})`;
            devLog(`🖱️ Clicked object: ${obj.name || obj.type || obj.id}`);
          } else {
            clickInfo += 'Empty map area';
          }

          document.getElementById('devClickInfo').textContent = clickInfo;
          updateDevStats();
        });

        // Listen to zoom changes
        mapView.on('camera-change', () => {
          if (devPanel.style.display === 'block') {
            updateDevStats();
          }
        });

        // Listen to floor changes
        mapView.on('floor-change', (event) => {
          devLog(`🏢 Floor changed to: ${event.floor.name || 'Floor ' + event.floor.elevation}`);
          updateDevStats();
        });

        // Initial environment setup log
        devLog('✅ Map loaded successfully');
        devLog(`📊 ${exhibitorMarkers.length} exhibitors, ${categoryMarkers.restrooms.length} restrooms`);
        devLog(`📍 ${allLabels.length} labels created`);
        updateDevStats();

      } catch (error) {
        status.textContent = `❌ Error: ${error.message}`;
        status.style.background = '#dc3545';
        status.style.color = 'white';
        console.error(error);
      }

      // Update label visibility based on zoom level
      function updateLabelVisibility(zoomLevel) {
        currentZoom = zoomLevel;

        // Main areas: visible at zoom >= 18
        labelCategories.mainAreas.forEach(label => {
          mapView.updateState(label, { enabled: zoomLevel >= ZOOM_THRESHOLDS.MAIN_AREAS });
        });

        // Amenities: visible at zoom >= 20
        labelCategories.amenities.forEach(label => {
          mapView.updateState(label, { enabled: zoomLevel >= ZOOM_THRESHOLDS.AMENITIES });
        });

        // Booths: visible at zoom >= 22
        labelCategories.booths.forEach(label => {
          mapView.updateState(label, { enabled: zoomLevel >= ZOOM_THRESHOLDS.BOOTHS });
        });

        // Exhibitors: always visible (no update needed)
        console.log(`🔍 Zoom: ${zoomLevel.toFixed(1)} | Labels visible: Exhibitors (${labelCategories.exhibitors.length}), Main Areas (${zoomLevel >= ZOOM_THRESHOLDS.MAIN_AREAS ? labelCategories.mainAreas.length : 0}), Amenities (${zoomLevel >= ZOOM_THRESHOLDS.AMENITIES ? labelCategories.amenities.length : 0}), Booths (${zoomLevel >= ZOOM_THRESHOLDS.BOOTHS ? labelCategories.booths.length : 0})`);
      }

      // Setup camera zoom listener for dynamic label visibility
      function setupCameraZoomListener() {
        mapView.on('camera-change', (event) => {
          // Get current zoom from camera directly (event structure varies)
          const newZoom = mapView.Camera.zoom;

          // Only update if zoom changed significantly (avoid excessive updates)
          if (newZoom && Math.abs(newZoom - currentZoom) > 0.5) {
            updateLabelVisibility(newZoom);
          }
        });

        console.log('✅ Camera zoom listener initialized for dynamic label visibility');
      }

      // Floor Selector (with buildings/areas if available)
      function setupFloorSelector() {
        const floors = mapData.getByType('floor');
        const buildings = mapData.getByType('building') || [];

        // Log available data for debugging
        console.log('📊 Floor/Building Data:');
        console.log('- Floors:', floors.length, floors.map(f => f.name || f.elevation));
        console.log('- Buildings:', buildings.length, buildings.map(b => b.name));

        if (floors.length <= 1 && buildings.length === 0) {
          console.log('ℹ️ Single floor, no buildings - floor selector hidden');
          return;
        }

        const container = document.getElementById('floorSelectorContainer');
        const floorSelect = document.getElementById('floorSelect');

        container.style.display = 'block';
        floorSelect.innerHTML = '';

        // Add buildings as optgroups if available
        if (buildings.length > 0) {
          buildings.forEach(building => {
            const optgroup = document.createElement('optgroup');
            optgroup.label = `🏢 ${building.name || 'Building'}`;

            const buildingFloors = floors.filter(f => f.building?.id === building.id);
            buildingFloors.forEach(floor => {
              const option = document.createElement('option');
              option.value = floor.id;
              option.textContent = floor.name || `Level ${floor.elevation}`;
              if (floor.id === mapView.currentFloor.id) option.selected = true;
              optgroup.appendChild(option);
            });

            floorSelect.appendChild(optgroup);
          });

          // Add floors without buildings
          const unassignedFloors = floors.filter(f => !f.building);
          if (unassignedFloors.length > 0) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = '📍 Other Floors';
            unassignedFloors.forEach(floor => {
              const option = document.createElement('option');
              option.value = floor.id;
              option.textContent = floor.name || `Level ${floor.elevation}`;
              if (floor.id === mapView.currentFloor.id) option.selected = true;
              optgroup.appendChild(option);
            });
            floorSelect.appendChild(optgroup);
          }
        } else {
          // No buildings - just list floors
          floors.forEach(floor => {
            const option = document.createElement('option');
            option.value = floor.id;
            option.textContent = floor.name || `Level ${floor.elevation}`;
            if (floor.id === mapView.currentFloor.id) option.selected = true;
            floorSelect.appendChild(option);
          });
        }

        // Setup floor selector dropdown
        floorSelect.addEventListener('change', (e) => {
          mapView.setFloor(e.target.value);
        });

        mapView.on('floor-change', (event) => {
          floorSelect.value = event.floor.id;
        });

        console.log(`✅ Floor selector initialized (${floors.length} floors, ${buildings.length} buildings)`);
      }

      // Smart Labels with Zoom-Based Visibility
      function setupLabels() {
        const spaces = mapData.getByType('space').filter(s => s.name);

        // Keywords for categorization
        const mainAreaKeywords = ['hall', 'entrance', 'lobby', 'atrium', 'plaza', 'pavilion', 'gallery'];
        const amenityKeywords = ['restroom', 'toilet', 'bathroom', 'elevator', 'escalator', 'stairs'];
        const exhibitorKeywords = ['booth', 'exhibit', 'stand', 'kiosk'];

        spaces.forEach(space => {
          const nameLower = space.name.toLowerCase();
          let category = 'booths'; // default
          let rank = 'low';
          let enabled = false; // Start disabled, controlled by zoom

          // Categorize by name and assign rank
          if (mainAreaKeywords.some(keyword => nameLower.includes(keyword))) {
            category = 'mainAreas';
            rank = 'high';
          } else if (amenityKeywords.some(keyword => nameLower.includes(keyword))) {
            category = 'amenities';
            rank = 'medium';
          } else if (space.externalId && space.externalId.match(/^\d+$/)) {
            // Booth number pattern (numeric externalId)
            category = 'booths';
            rank = 'low';
          }

          // Create label with rank
          const label = mapView.Labels.add(space, space.name, {
            interactive: false,
            rank: rank,
            enabled: enabled, // Start disabled
            appearance: {
              textSize: category === 'mainAreas' ? 17 : 14,
              color: category === 'mainAreas' ? '#000' : '#333',
              textStrokeColor: 'rgba(255, 255, 255, 0.6)',
              textStrokeWidth: 1.5
            }
          });

          // Store in appropriate category
          labelCategories[category].push(label);
          allLabels.push(label);
        });

        // Add exhibitor labels (always visible)
        const exhibitors = getAllExhibitors();
        exhibitors.forEach(exhibitor => {
          if (exhibitor.details?.name) {
            const label = mapView.Labels.add(
              exhibitor,
              `${exhibitor.details.externalId} - ${exhibitor.details.name}`,
              {
                interactive: false,
                rank: 'always-visible',
                enabled: true, // Always enabled
                appearance: {
                  textSize: 14,
                  color: '#14b8a6',
                  textStrokeColor: 'rgba(255, 255, 255, 0.6)',
                  textStrokeWidth: 1.5
                }
              }
            );
            labelCategories.exhibitors.push(label);
            allLabels.push(label);
          }
        });

        console.log(`✅ Smart labels initialized:
  - ${labelCategories.exhibitors.length} exhibitor labels (always visible)
  - ${labelCategories.mainAreas.length} main area labels (zoom >= ${ZOOM_THRESHOLDS.MAIN_AREAS})
  - ${labelCategories.amenities.length} amenity labels (zoom >= ${ZOOM_THRESHOLDS.AMENITIES})
  - ${labelCategories.booths.length} booth labels (zoom >= ${ZOOM_THRESHOLDS.BOOTHS})`);

        // Set initial visibility based on current zoom
        updateLabelVisibility(currentZoom);
      }

      // Helper function to show amenity details when clicked (defined at outer scope)
      function showAmenityDetails(amenity, amenityType, amenityName) {
        const cardTitle = document.getElementById('cardTitle');
        const cardSubtitle = document.getElementById('cardSubtitle');
        const cardBooth = document.getElementById('cardBooth');
        const cardDescription = document.getElementById('cardDescription');
        const cardPrimaryActions = document.getElementById('cardPrimaryActions');
        const exhibitorCard = document.getElementById('exhibitorCard');

        cardTitle.textContent = amenityName || amenityType || 'Amenity';
        cardSubtitle.style.display = 'none';
        cardBooth.style.display = 'none';

        // Build detailed description based on amenity data
        let description = `<div style="padding: 8px 0;">`;

        // Add amenity type with icon
        description += `<p><strong>Type:</strong> ${amenityName || amenityType}</p>`;

        // Add location details if available
        if (amenity.details?.name) {
          description += `<p><strong>Name:</strong> ${amenity.details.name}</p>`;
        }

        // Add floor information
        if (amenity.floor) {
          description += `<p><strong>Floor:</strong> ${amenity.floor.name || amenity.floor.elevation}</p>`;
        }

        // Add accessibility information for restrooms
        if (amenityType.includes('restroom')) {
          const isAccessible = amenityType.includes('accessible');
          description += `<div style="margin-top: 12px; padding: 12px; background: ${isAccessible ? '#e8f5e9' : '#f5f5f5'}; border-radius: 8px; border-left: 4px solid ${isAccessible ? '#28a745' : '#14b8a6'};">`;
          if (isAccessible) {
            description += `<strong style="color: #28a745;">♿ Accessible Restroom</strong><br>`;
            description += `<span style="font-size: 13px; color: #666;">This restroom is wheelchair accessible and meets ADA standards.</span>`;
          } else {
            description += `<strong>Standard Restroom</strong><br>`;
            description += `<span style="font-size: 13px; color: #666;">For accessible facilities, look for the wheelchair icon <i data-lucide="accessibility" style="width:14px;height:14px;display:inline;"></i></span>`;
          }
          description += `</div>`;
        }

        // Add elevator/stairs information
        if (amenityType.includes('elevator') || amenityType.includes('lift')) {
          description += `<div style="margin-top: 12px; padding: 12px; background: #e8f5e9; border-radius: 8px; border-left: 4px solid #28a745;">`;
          description += `<strong style="color: #28a745;">♿ Accessible Route</strong><br>`;
          description += `<span style="font-size: 13px; color: #666;">Elevator provides accessible connection between floors.</span>`;
          description += `</div>`;
        } else if (amenityType.includes('stairs')) {
          description += `<div style="margin-top: 12px; padding: 12px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #ffc107;">`;
          description += `<strong style="color: #856404;">⚠️ Stairs Only</strong><br>`;
          description += `<span style="font-size: 13px; color: #666;">For accessible routes, please use elevators marked with <i data-lucide="move-vertical" style="width:14px;height:14px;display:inline;"></i></span>`;
          description += `</div>`;
        }

        description += `</div>`;

        cardDescription.innerHTML = description;

        // Show action buttons
        cardPrimaryActions.style.display = 'flex';
        const shareBtn = document.getElementById('shareBtn');
        shareBtn.style.display = 'none'; // Hide share for amenities

        // Setup Directions button
        const directionsBtn = document.getElementById('directionsBtn');
        directionsBtn.onclick = () => {
          const navigationPanel = document.getElementById('navigationPanel');
          navigationPanel.style.display = 'block';

          const navToInput = document.getElementById('navToInput');
          navToInput.value = amenityName || amenityType || 'Amenity';
          navToInput.dataset.spaceId = amenity.id;

          if (window.lucide) lucide.createIcons();
        };

        exhibitorCard.classList.add('show');
        mapView.Camera.focusOn(amenity);

        // Re-initialize Lucide icons in the description
        if (window.lucide) lucide.createIcons();

        console.log('📋 Showing amenity details:', amenityName || amenityType);
      }

      // Amenities - Icons for restrooms, exits, etc.
      // Marker Priority System (Mappedin rank - HIGHER = MORE IMPORTANT for camera focus):
      // - Rank 10: Exhibitors (always prioritized)
      // - Rank 9: High Priority POIs (restrooms, toilets, cafes, food/beverage)
      // - Rank 8: Medium Priority POIs (elevators, stairs, info desks)
      // - Rank 5: Drop Pin (user-placed)
      // - Rank 1: Low Priority (rooms, meeting spaces)
      function setupAmenities() {
        const amenities = mapData.getByType('amenity') || [];
        const locations = mapData.getByType('location') || [];
        const connections = mapData.getByType('connection') || [];

        console.log(`\n🔗 Checking Mappedin Connections (stairs, elevators, etc.):`);
        console.log(`   - Total connections found: ${connections.length}`);

        // Lucide icon mapping for amenities - SF Symbols web equivalent
        const amenityIcons = {
          // Restrooms - different icons for different types
          'restroom': 'bath',
          'restroom-accessible': 'accessibility',
          'restroom-mens': 'user',
          'restroom-womens': 'users',
          'restroom-gender-neutral': 'bath',
          'toilet': 'bath',
          'bathroom': 'bath',
          'wc': 'bath',
          'washroom': 'bath',
          // Navigation amenities
          'elevator': 'move-vertical',
          'lift': 'move-vertical',
          'escalator': 'chevrons-up',
          'stairs': 'arrow-up',
          'staircase': 'arrow-up',
          // Exits and entrances
          'exit': 'door-open',
          'emergency-exit': 'alert-triangle',
          'entrance': 'door-open',
          'door': 'door-closed',
          // Services
          'parking': 'car',
          'atm': 'credit-card',
          'information': 'info',
          'info': 'info',
          'help': 'help-circle',
          'phone': 'phone',
          'wifi': 'wifi',
          // Food & Beverage
          'cafe': 'coffee',
          'coffee': 'coffee',
          'restaurant': 'utensils',
          'food': 'utensils',
          'dining': 'utensils',
          'bar': 'wine',
          // Default
          'default': 'map-pin'
        };

        // Human-readable amenity names for details display
        const amenityNames = {
          'restroom': 'Restroom',
          'restroom-accessible': 'Accessible Restroom',
          'restroom-mens': "Men's Restroom",
          'restroom-womens': "Women's Restroom",
          'restroom-gender-neutral': 'Gender Neutral Restroom',
          'toilet': 'Restroom',
          'bathroom': 'Restroom',
          'wc': 'Restroom',
          'washroom': 'Restroom',
          'elevator': 'Elevator',
          'lift': 'Elevator',
          'escalator': 'Escalator',
          'stairs': 'Stairs',
          'staircase': 'Stairs',
          'exit': 'Exit',
          'emergency-exit': 'Emergency Exit',
          'entrance': 'Entrance',
          'parking': 'Parking',
          'atm': 'ATM',
          'information': 'Information',
          'phone': 'Phone',
          'wifi': 'WiFi',
          'cafe': 'Cafe',
          'coffee': 'Coffee Shop',
          'restaurant': 'Restaurant',
          'food': 'Food Court',
          'dining': 'Dining Area',
          'bar': 'Bar'
        };

        const restroomKeywords = ['restroom', 'toilet', 'bathroom', 'wc', 'washroom'];
        const cafeKeywords = ['cafe', 'coffee', 'restaurant', 'food', 'dining', 'bar', 'bistro', 'cafeteria'];
        const accessibleKeywords = ['accessible', 'wheelchair', 'handicap', 'ada'];
        const mensKeywords = ['men', 'male', 'mens', "men's", 'gents'];
        const womensKeywords = ['women', 'female', 'womens', "women's", 'ladies'];
        const amenityKeywords = ['elevator', 'lift', 'escalator', 'stairs', 'staircase', 'exit'];
        const poiKeywords = [...cafeKeywords, 'atm', 'information', 'help', 'desk'];
        const roomKeywords = ['room', 'hall', 'conference', 'meeting', 'auditorium', 'theater', 'theatre', 'lounge', 'suite', 'boardroom', 'office', 'balcony'];

        // Category IDs (from location-categories.json)
        const restroomCategoryIds = [
          'lcat_949158e6f42d5a22',  // All Gender Restroom
          'lcat_9ca8623837d4867f',  // Men's Restroom
          'lcat_accessible_restroom' // Accessible Restroom (example)
        ];

        const cafeCategoryIds = [
          'lcat_cafe',              // Cafe (will detect actual IDs from your venue)
          'lcat_coffee',            // Coffee shop
          'lcat_restaurant',        // Restaurant
          'lcat_food',              // Food court
          'lcat_dining'             // Dining area
        ];

        // Helper function to determine specific restroom type
        function getRestroomType(name) {
          const nameLower = (name || '').toLowerCase();
          const isAccessible = accessibleKeywords.some(kw => nameLower.includes(kw));
          const isMens = mensKeywords.some(kw => nameLower.includes(kw));
          const isWomens = womensKeywords.some(kw => nameLower.includes(kw));

          if (isAccessible) return 'restroom-accessible';
          if (isMens) return 'restroom-mens';
          if (isWomens) return 'restroom-womens';
          return 'restroom';
        }

        // Helper function to create Lucide icon marker
        function createAmenityMarker(iconName, amenityType, color = '#14b8a6') {
          // Special styling for restrooms - solid light blue circle with white icon
          const isRestroom = amenityType.includes('restroom') || amenityType.includes('toilet') || amenityType.includes('bathroom');

          if (isRestroom) {
            // Solid light blue circle for restrooms - smaller size, thicker stroke
            return `
              <div class="amenity-marker" style="
                background: #42a5f5;
                color: white;
                padding: 6px;
                border-radius: 50%;
                box-shadow: 0 2px 8px rgba(66, 165, 245, 0.4);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
              " onmouseover="this.style.transform='scale(1.15)';this.style.boxShadow='0 4px 16px rgba(66, 165, 245, 0.6)'"
                 onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 2px 8px rgba(66, 165, 245, 0.4)'">
                <i data-lucide="bath" style="width:12px;height:12px;stroke-width:3;"></i>
              </div>
            `;
          } else {
            // Standard white circle for other amenities
            return `
              <div class="amenity-marker" style="
                background: white;
                color: ${color};
                padding: 10px;
                border-radius: 50%;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
              " onmouseover="this.style.transform='scale(1.1)';this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)'"
                 onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 2px 8px rgba(0,0,0,0.2)'">
                <i data-lucide="${iconName}" style="width:24px;height:24px;"></i>
              </div>
            `;
          }
        }

        let amenityCount = 0;

        // Method 1: Use Mappedin's amenity data if available
        if (amenities.length > 0) {
          amenities.forEach(amenity => {
            const type = amenity.type?.toLowerCase() || 'default';
            const amenityType = restroomKeywords.some(kw => type.includes(kw)) ? getRestroomType(amenity.name) : type;
            const iconName = amenityIcons[amenityType] || amenityIcons[type] || amenityIcons.default;
            const amenityName = amenityNames[amenityType] || amenityNames[type] || type;

            // Color code: Accessible = green, Regular amenities = teal
            const color = amenityType.includes('accessible') ? '#28a745' : '#14b8a6';
            const markerHTML = createAmenityMarker(iconName, amenityType, color);

            const isRestroom = restroomKeywords.some(kw => type.includes(kw));
            const isCafe = cafeKeywords.some(kw => type.includes(kw));
            // High priority for restrooms & cafes (9), medium for other amenities (8)
            const rank = (isRestroom || isCafe) ? 9 : 8;

            const marker = mapView.Markers.add(amenity, markerHTML, {
              anchor: 'center',
              rank,
              interactive: true
            });

            // Store amenity info with marker for click handling
            marker._amenityData = {
              amenity,
              amenityType,
              amenityName
            };

            // Categorize by type
            if (isRestroom) {
              categoryMarkers.restrooms.push(marker);
            } else {
              categoryMarkers.amenities.push(marker);
            }

            amenityCount++;
          });

          console.log(`✅ Added ${amenityCount} amenity icons from Mappedin amenity data`);

          // Initialize Lucide icons for these markers (need slight delay for DOM update)
          setTimeout(() => {
            if (window.lucide) {
              lucide.createIcons();
              console.log('🎨 Lucide icons initialized for Method 1 amenities');
            }
          }, 100);
        }

        // Method 2: Check locations with categories (for restrooms, etc.)
        let categoryRestroomCount = 0;
        locations.forEach(location => {
          if (location.categories && location.categories.length > 0) {
            const hasRestroomCategory = location.categories.some(catId =>
              restroomCategoryIds.includes(catId)
            );

            if (hasRestroomCategory) {
              // Determine specific restroom type from location name
              const restroomType = getRestroomType(location.details?.name);
              const iconName = amenityIcons[restroomType];
              const amenityName = amenityNames[restroomType];
              const color = restroomType.includes('accessible') ? '#28a745' : '#14b8a6';

              const markerHTML = createAmenityMarker(iconName, restroomType, color);

              const marker = mapView.Markers.add(location, markerHTML, {
                anchor: 'center',
                rank: 9,  // High priority - restrooms/toilets/cafes
                interactive: true
              });

              // Store amenity info with marker for click handling
              marker._amenityData = {
                amenity: location,
                amenityType: restroomType,
                amenityName
              };

              categoryMarkers.restrooms.push(marker);
              categoryRestroomCount++;
            }
          }
        });

        if (categoryRestroomCount > 0) {
          console.log(`✅ Added ${categoryRestroomCount} restrooms from location categories`);

          // Initialize Lucide icons for these markers
          setTimeout(() => {
            if (window.lucide) {
              lucide.createIcons();
              console.log('🎨 Lucide icons initialized for Method 2 restrooms');
            }
          }, 100);
        } else {
          console.log(`ℹ️ No restrooms found in location categories (checked ${locations.length} locations)`);
          console.log(`ℹ️ Looking for category IDs: ${restroomCategoryIds.join(', ')}`);
        }

        // Method 2b: Check locations with categories (for cafes/food)
        let categoryCafeCount = 0;
        locations.forEach(location => {
          if (location.categories && location.categories.length > 0) {
            const hasCafeCategory = location.categories.some(catId =>
              cafeCategoryIds.includes(catId)
            );

            // Also check if name contains cafe keywords
            const nameLower = (location.details?.name || '').toLowerCase();
            const hasCafeName = cafeKeywords.some(kw => nameLower.includes(kw));

            if (hasCafeCategory || hasCafeName) {
              // Determine specific cafe type from name
              let cafeType = 'cafe';
              let iconName = 'coffee';

              if (nameLower.includes('restaurant') || nameLower.includes('dining')) {
                cafeType = 'restaurant';
                iconName = 'utensils';
              } else if (nameLower.includes('bar')) {
                cafeType = 'bar';
                iconName = 'wine';
              } else if (nameLower.includes('food')) {
                cafeType = 'food';
                iconName = 'utensils';
              }

              const amenityName = amenityNames[cafeType] || location.details?.name || 'Cafe';

              // Orange/amber color for food/beverage
              const markerHTML = `
                <div class="amenity-marker" style="
                  background: #fff3e0;
                  color: #ef6c00;
                  padding: 10px;
                  border-radius: 50%;
                  box-shadow: 0 2px 8px rgba(239, 108, 0, 0.3);
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  cursor: pointer;
                  transition: transform 0.2s, box-shadow 0.2s;
                  border: 2px solid #ef6c00;
                " onmouseover="this.style.transform='scale(1.15)';this.style.boxShadow='0 4px 16px rgba(239, 108, 0, 0.5)'"
                   onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 2px 8px rgba(239, 108, 0, 0.3)'">
                  <i data-lucide="${iconName}" style="width:24px;height:24px;"></i>
                </div>
              `;

              const marker = mapView.Markers.add(location, markerHTML, {
                anchor: 'center',
                rank: 9,  // High priority - cafes/food
                interactive: true
              });

              // Store amenity info with marker for click handling
              marker._amenityData = {
                amenity: location,
                amenityType: cafeType,
                amenityName
              };

              categoryMarkers.amenities.push(marker);
              categoryCafeCount++;
            }
          }
        });

        if (categoryCafeCount > 0) {
          console.log(`✅ Added ${categoryCafeCount} cafes/restaurants from location categories/names`);

          // Initialize Lucide icons for these markers
          setTimeout(() => {
            if (window.lucide) {
              lucide.createIcons();
              console.log('🎨 Lucide icons initialized for Method 2b cafes');
            }
          }, 100);
        } else {
          console.log(`ℹ️ No cafes found in location categories (checked ${locations.length} locations)`);
        }

        // Method 3: Detect rooms/meeting spaces from location names
        let roomCount = 0;
        locations.forEach(location => {
          if (!location.details?.name) return;

          const nameLower = location.details.name.toLowerCase();
          const matchedKeyword = roomKeywords.find(keyword => nameLower.includes(keyword));

          if (matchedKeyword && !location.categories?.length) {  // Don't duplicate restrooms
            const markerHTML = createAmenityMarker('door-open', 'room', '#14b8a6');

            const marker = mapView.Markers.add(location, markerHTML, {
              anchor: 'center',
              rank: 1,  // Low priority - rooms (less important than POIs)
              interactive: true
            });

            // Store amenity info with marker for click handling
            marker._amenityData = {
              amenity: location,
              amenityType: 'room',
              amenityName: location.details.name
            };

            categoryMarkers.rooms.push(marker);
            roomCount++;
          }
        });

        if (roomCount > 0) {
          console.log(`✅ Added ${roomCount} meeting rooms/spaces from location names`);

          // Initialize Lucide icons for these markers
          setTimeout(() => {
            if (window.lucide) {
              lucide.createIcons();
              console.log('🎨 Lucide icons initialized for Method 3 rooms');
            }
          }, 100);
        }

        // Method 4: Check Mappedin connections (stairs, elevators, escalators, ramps)
        let connectionCount = 0;
        connections.forEach(connection => {
          if (!connection) return;

          const connectionType = (connection.type || '').toLowerCase();
          const connectionName = connection.name || connectionType;

          // Only process navigation connections (elevators, stairs, escalators, ramps)
          if (!connectionType || !['elevator', 'stairs', 'escalator', 'ramp', 'lift', 'stairway', 'staircase'].includes(connectionType)) {
            return;
          }

          // Map connection type to our amenity icon
          let iconName = amenityIcons[connectionType] || 'arrow-up';
          let amenityName = amenityNames[connectionType] || connectionName || 'Connection';
          const color = '#14b8a6';

          const markerHTML = createAmenityMarker(iconName, connectionType, color);

          // Try to get a coordinate for the connection
          // Connections might have entrance/exit spaces or coordinates
          let coordinate = connection.coordinate || connection.entrance?.coordinate || connection.exit?.coordinate;

          if (coordinate) {
            const marker = mapView.Markers.add(coordinate, markerHTML, {
              anchor: 'center',
              rank: 8,  // High priority - navigation amenities
              interactive: true
            });

            // Store connection info with marker for click handling
            marker._amenityData = {
              amenity: connection,
              amenityType: connectionType,
              amenityName
            };

            categoryMarkers.amenities.push(marker);
            connectionCount++;
          }
        });

        if (connectionCount > 0) {
          console.log(`✅ Added ${connectionCount} connections (stairs/elevators) from Mappedin connection data`);

          // Initialize Lucide icons for these markers
          setTimeout(() => {
            if (window.lucide) {
              lucide.createIcons();
              console.log('🎨 Lucide icons initialized for Method 4 connections');
            }
          }, 100);
        } else {
          console.log(`ℹ️ No usable connections found (checked ${connections.length} connections)`);

          // Log connection types for debugging
          if (connections.length > 0) {
            const connectionTypes = connections.map(c => c?.type || 'unknown').filter((v, i, a) => a.indexOf(v) === i);
            console.log(`   Connection types in data: ${connectionTypes.join(', ')}`);
          }
        }

        // Method 5: Fallback - Detect amenities from space names (if no other data)
        if (amenities.length === 0 && categoryRestroomCount === 0 && roomCount === 0 && connectionCount === 0) {
          console.log('ℹ️ No Mappedin amenity/location/connection data - detecting from space names...');

          const allSpaces = mapData.getByType('space');
          const allKeywords = [...restroomKeywords, ...amenityKeywords, ...roomKeywords];

          allSpaces.forEach(space => {
            if (!space.name) return;

            const nameLower = space.name.toLowerCase();
            const matchedKeyword = allKeywords.find(keyword => nameLower.includes(keyword));

            if (matchedKeyword) {
              // Determine specific type
              let amenityType = matchedKeyword;
              if (restroomKeywords.includes(matchedKeyword)) {
                amenityType = getRestroomType(space.name);
              }

              const iconName = amenityIcons[amenityType] || amenityIcons[matchedKeyword] || amenityIcons.default;
              const amenityName = amenityNames[amenityType] || amenityNames[matchedKeyword] || matchedKeyword;
              const color = amenityType.includes('accessible') ? '#28a745' : '#14b8a6';

              const markerHTML = createAmenityMarker(iconName, amenityType, color);

              // Determine category and rank
              let category;
              let rank;

              if (restroomKeywords.includes(matchedKeyword)) {
                category = 'restrooms';
                rank = 9;  // High priority - restrooms/toilets
              } else if (cafeKeywords.includes(matchedKeyword)) {
                category = 'amenities';
                rank = 9;  // High priority - cafes/food
              } else if (roomKeywords.includes(matchedKeyword)) {
                category = 'rooms';
                rank = 1;  // Low priority - rooms
              } else {
                category = 'amenities';
                rank = 8;  // High priority - elevators, stairs, POIs
              }

              const marker = mapView.Markers.add(space, markerHTML, {
                anchor: 'center',
                rank: rank,
                interactive: true
              });

              // Store amenity info with marker for click handling
              marker._amenityData = {
                amenity: space,
                amenityType,
                amenityName
              };

              // Add to appropriate category
              if (category && categoryMarkers[category]) {
                categoryMarkers[category].push(marker);
              }
            }
          });
        }

        // Final icon initialization after all amenity markers added
        setTimeout(() => {
          if (window.lucide) {
            lucide.createIcons();
            console.log('🎨 Final Lucide icons pass for all amenity markers');
          } else {
            console.warn('⚠️ Lucide not available - icons may not render');
          }
        }, 200);

        // Summary of all categories detected
        const totalMarkers = categoryMarkers.amenities.length +
                            categoryMarkers.restrooms.length +
                            categoryMarkers.rooms.length;

        console.log(`\n📊 Amenity Detection Summary:`);
        console.log(`   - Amenities: ${categoryMarkers.amenities.length}`);
        console.log(`   - Restrooms: ${categoryMarkers.restrooms.length}`);
        console.log(`   - Rooms: ${categoryMarkers.rooms.length}`);
        console.log(`   - Total: ${totalMarkers} markers`);

        console.log(`\n🎯 Priority System (Camera Focus):`);
        console.log(`   - Rank 10: Exhibitors (highest priority)`);
        console.log(`   - Rank 9: Restrooms, Toilets, Cafes, Food/Beverage`);
        console.log(`   - Rank 8: Elevators, Stairs, POIs`);
        console.log(`   - Rank 5: Drop Pin`);
        console.log(`   - Rank 1: Rooms (lowest priority)`);

        // Enhanced Data Validation & Testing
        console.log(`\n🧪 Mappedin Data Validation:`);
        console.log(`   - Amenity objects from API: ${amenities.length}`);
        console.log(`   - Location objects: ${locations.length}`);
        console.log(`   - Locations with categories: ${locations.filter(l => l.categories?.length).length}`);

        if (amenities.length > 0) {
          console.log(`\n🔍 Sample Amenity Data (first 3):`);
          amenities.slice(0, 3).forEach(amenity => {
            console.log(`   - Type: ${amenity.type || 'unknown'}, Name: ${amenity.name || 'N/A'}, ID: ${amenity.id}`);
          });
        }

        if (categoryRestroomCount > 0) {
          console.log(`\n🚻 Restroom Categories Found:`);
          const restroomLocations = locations.filter(l =>
            l.categories?.some(catId => restroomCategoryIds.includes(catId))
          );
          restroomLocations.slice(0, 3).forEach(loc => {
            const restroomType = getRestroomType(loc.details?.name);
            console.log(`   - Name: ${loc.details?.name || 'N/A'}, Type: ${restroomType}, Categories: ${loc.categories?.join(', ')}`);
          });
        }

        // Test icon rendering
        console.log(`\n✅ Lucide Icons Initialized: ${window.lucide ? 'YES' : 'NO'}`);
        console.log(`   - Icon mapping complete for ${Object.keys(amenityIcons).length} amenity types`);
        console.log(`   - Click handlers enabled on all amenity markers`);
        console.log(`   - Accessible restrooms (green icons): ${categoryMarkers.restrooms.length > 0 ? 'Detected' : 'None found'}`);

        // WebView & iframe compatibility check
        console.log(`\n📱 Environment Check:`);
        console.log(`   - User Agent: ${navigator.userAgent.includes('Mobile') ? 'Mobile' : 'Desktop'}`);
        console.log(`   - In iframe: ${window.self !== window.top}`);
        console.log(`   - Touch events: ${('ontouchstart' in window) ? 'Supported' : 'Not supported'}`);
        console.log(`   - Viewport width: ${window.innerWidth}px`);
      }

      // Exhibitor Markers with Nice Labels (using real location data)
      function setupExhibitors() {
        const exhibitors = getAllExhibitors();

        console.log(`📍 Found ${exhibitors.length} exhibitors with name and booth number`);

        // Log sample exhibitors
        const sample = exhibitors.slice(0, 10).map(loc => ({
          name: loc.details.name,
          booth: loc.details.externalId
        }));
        console.log('📋 Sample exhibitors:', sample);

        // Add markers to locations
        exhibitors.forEach(location => {
          const labelText = `${location.details.externalId} - ${location.details.name}`;

          // Add marker with enhanced styling using Lucide icon
          const markerHTML = `
            <div style="
              background: linear-gradient(135deg, #14b8a6 0%, #06b6d4 100%);
              color: white;
              padding: 10px 16px;
              border-radius: 20px;
              font-size: 13px;
              font-weight: 600;
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
              cursor: pointer;
              white-space: nowrap;
              border: 2px solid rgba(255,255,255,0.3);
              transition: transform 0.2s;
              display: flex;
              align-items: center;
              gap: 6px;
            " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
              <i data-lucide="map-pin" style="width:18px;height:18px;"></i>
              <span>${labelText}</span>
            </div>
          `;

          const marker = mapView.Markers.add(location, markerHTML, {
            anchor: 'center',
            rank: 10,
            interactive: true
          });

          // Store exhibitor location with marker for click handling
          marker._exhibitorLocation = location;

          exhibitorMarkers.push({ marker, location });
        });

        console.log(`✅ Added ${exhibitorMarkers.length} exhibitor markers`);
      }

      // Make ALL spaces and objects clickable with hover effects
      function setupSpaceInteractivity() {
        // Make ALL spaces interactive (not just ones with externalId)
        const allSpaces = mapData.getByType('space');

        console.log(`🎨 Making ${allSpaces.length} spaces interactive...`);

        allSpaces.forEach(space => {
          mapView.updateState(space, {
            interactive: true,
            hoverColor: '#14b8a6',  // Purple hover effect
            color: space.externalId ? '#e0e0e0' : undefined  // Light gray for booths, default for others
          });
        });

        // Make ALL objects interactive (booths, furniture, displays, etc.)
        const allObjects = mapData.getByType('object') || [];
        console.log(`🏢 Making ${allObjects.length} objects interactive...`);

        allObjects.forEach(obj => {
          mapView.updateState(obj, {
            interactive: true,
            hoverColor: '#14b8a6'
          });

          // Add labels to objects with names (exhibitor objects rank 10 - highest priority)
          if (obj.name) {
            mapView.Labels.add(obj, obj.name, {
              interactive: false,
              rank: 10,  // Rank 10 for exhibitor objects (highest priority)
              appearance: {
                textSize: 14,
                color: '#333',
                textStrokeColor: 'rgba(255, 255, 255, 0.6)',
                textStrokeWidth: 1.5
              }
            });
          }
        });

        // Handle hover events for preview
        mapView.on('hover', (event) => {
          const status = document.getElementById('status');

          if (event?.objects?.length > 0) {
            const obj = event.objects[0];
            status.textContent = `🏢 Hovering: ${obj.name || obj.type || 'Object'}`;
            status.style.background = '#14b8a6';
          } else if (event?.spaces?.length > 0) {
            const space = event.spaces[0];
            const displayName = space.name || space.externalId || 'Space';
            status.textContent = `🎯 Hovering: ${displayName}`;
            status.style.background = '#14b8a6';
          } else {
            status.textContent = '👆 Click any booth or object to see details';
            status.style.background = '#333';
          }
        });

        // Handle click events with proper priority
        mapView.on('click', (event) => {
          // Priority 1: Markers (custom UI - amenities and exhibitors)
          if (event?.markers?.length > 0) {
            const marker = event.markers[0];

            // Check if it's an amenity marker
            if (marker._amenityData) {
              const { amenity, amenityType, amenityName } = marker._amenityData;
              showAmenityDetails(amenity, amenityType, amenityName);
              return;
            }

            // Check if it's an exhibitor marker
            if (marker._exhibitorLocation) {
              showCardForLocation(marker._exhibitorLocation, true);
              return;
            }

            return; // Unknown marker type
          }

          // Priority 2: Labels (specific annotations)
          if (event?.labels?.length > 0) {
            console.log('📝 Label clicked:', event.labels[0]);
            // Handle label clicks if needed
            return;
          }

          // Priority 3: Map Objects (doors, windows, furniture, booths, toilets)
          if (event?.objects?.length > 0) {
            const mapObject = event.objects[0];
            console.log('🏢 Object clicked:', mapObject.type, mapObject.name, mapObject);

            // Show object details with navigation
            const cardTitle = document.getElementById('cardTitle');
            const cardBooth = document.getElementById('cardBooth');
            const cardDescription = document.getElementById('cardDescription');
            const cardPrimaryActions = document.getElementById('cardPrimaryActions');
            const cardActions = document.getElementById('cardActions');
            const exhibitorCard = document.getElementById('exhibitorCard');

            cardTitle.textContent = mapObject.name || `${mapObject.type || 'Object'}`;
            cardBooth.textContent = `Type: ${mapObject.type || 'Unknown'}`;
            cardBooth.style.display = 'inline-block';
            cardDescription.innerHTML = `
              <p><strong>Type:</strong> ${mapObject.type || 'Unknown'}</p>
              <p><strong>ID:</strong> ${mapObject.id}</p>
              ${mapObject.externalId ? `<p><strong>External ID:</strong> ${mapObject.externalId}</p>` : ''}
            `;

            // Show Directions button for objects
            cardPrimaryActions.style.display = 'flex';
            cardActions.style.display = 'flex';

            // Setup Directions button
            const directionsBtn = document.getElementById('directionsBtn');
            directionsBtn.onclick = () => {
              const navigationPanel = document.getElementById('navigationPanel');
              navigationPanel.style.display = 'block';

              // Pre-fill "To" field with object
              const navToInput = document.getElementById('navToInput');
              navToInput.value = mapObject.name || mapObject.type || 'Selected Object';
              navToInput.dataset.spaceId = mapObject.id;

              // Re-initialize icons
              if (window.lucide) lucide.createIcons();
            };

            // Hide share button for objects (they don't have booth numbers)
            const shareBtn = document.getElementById('shareBtn');
            shareBtn.style.display = 'none';

            exhibitorCard.classList.add('show');
            mapView.Camera.focusOn(mapObject);

            return;
          }

          // Priority 4: Spaces (floor areas, rooms, booths)
          if (event?.spaces?.length > 0) {
            const space = event.spaces[0];
            showCardForSpace(space);
            return;
          }

          // Priority 5: Empty map click - close card
          const card = document.getElementById('exhibitorCard');
          card.style.display = 'none';
        });

        console.log(`✅ ${allSpaces.length} spaces + ${allObjects.length} objects are now interactive with hover effects`);
      }

      // Show card for a space
      function showCardForSpace(space, showNavigate = false) {
        const cardTitle = document.getElementById('cardTitle');
        const cardSubtitle = document.getElementById('cardSubtitle');
        const cardBooth = document.getElementById('cardBooth');
        const cardDescription = document.getElementById('cardDescription');
        const cardActions = document.getElementById('cardActions');
        const exhibitorCard = document.getElementById('exhibitorCard');

        // Get exhibitor data if this is a booth
        const exhibitors = getExhibitorsByBooth(space.externalId);

        if (exhibitors.length > 0) {
          // Show exhibitor data
          if (exhibitors.length === 1) {
            // Single exhibitor
            const exhibitor = exhibitors[0];
            cardTitle.textContent = exhibitor.name;

            // Show booth number as subtitle
            if (space.externalId) {
              cardSubtitle.textContent = `Booth ${space.externalId}`;
              cardSubtitle.style.display = 'block';
            } else {
              cardSubtitle.style.display = 'none';
            }

            cardBooth.textContent = `📍 Booth ${space.externalId}`;
            cardBooth.style.display = 'inline-block';
            cardDescription.innerHTML = `
              <div style="margin-bottom: 8px;">
                <strong>🌍 ${exhibitor.country}</strong>
              </div>
              <p>${exhibitor.description}</p>
              ${exhibitor.website ? `<p><a href="${exhibitor.website}" target="_blank" style="color: #14b8a6;">🌐 Visit Website</a></p>` : ''}
              ${exhibitor.documents ? `<p>📄 Documents: ${exhibitor.documents.join(', ')}</p>` : ''}
            `;
          } else {
            // Multiple co-exhibitors
            cardTitle.textContent = `Booth ${space.externalId} - Co-Exhibitors`;
            cardSubtitle.style.display = 'none'; // Hide subtitle for multi-exhibitor
            cardBooth.textContent = `📍 ${exhibitors.length} Companies`;
            cardBooth.style.display = 'inline-block';
            cardDescription.innerHTML = exhibitors.map(ex => `
              <div style="margin: 16px 0; padding: 12px; border-left: 3px solid #14b8a6; background: rgba(20, 184, 166, 0.05);">
                <strong style="font-size: 16px;">${ex.name}</strong>
                <div style="margin: 4px 0; color: #666;">🌍 ${ex.country}</div>
                <p style="margin: 8px 0;">${ex.description}</p>
                ${ex.website ? `<a href="${ex.website}" target="_blank" style="color: #14b8a6;">🌐 Visit Website</a>` : ''}
              </div>
            `).join('');
          }
        } else {
          // No exhibitor data - show space info
          cardTitle.textContent = space.name || 'Unnamed Space';
          cardSubtitle.style.display = 'none'; // Hide subtitle when no exhibitor data
          if (space.externalId) {
            cardBooth.textContent = `Booth ${space.externalId}`;
            cardBooth.style.display = 'inline-block';
          } else {
            cardBooth.style.display = 'none';
          }
          cardDescription.textContent = space.description || `This is ${space.name || 'a space'} in the venue. ${space.externalId ? 'No exhibitor data available for this booth.' : 'Click booths with numbers to see exhibitor info.'}`;
        }

        document.getElementById('cardCategories').innerHTML = '';

        // Show action buttons for ALL spaces (toilets, rooms, booths, etc.)
        const cardPrimaryActions = document.getElementById('cardPrimaryActions');
        const navigationPanel = document.getElementById('navigationPanel');

        // Always show Directions button, conditionally show Share button
        cardPrimaryActions.style.display = 'flex';
        cardActions.style.display = 'flex';

        // Setup Directions button - shows To/From panel
        const directionsBtn = document.getElementById('directionsBtn');
        directionsBtn.onclick = () => {
          // Show navigation panel
          navigationPanel.style.display = 'block';

          // Hide Directions button (replaced by navigation panel)
          directionsBtn.style.display = 'none';

          // Minimize card content - hide description, show only title
          const cardDescription = document.getElementById('cardDescription');
          const cardTitle = document.getElementById('cardTitle');

          // Store original description and title for restoration
          cardDescription.dataset.originalContent = cardDescription.innerHTML;
          cardTitle.dataset.originalContent = cardTitle.textContent;

          // Hide description
          cardDescription.style.display = 'none';

          // For co-exhibitors, simplify title to show only main booth/parent
          const exhibitors = getExhibitorsByBooth(space.externalId);
          if (exhibitors && exhibitors.length > 1) {
            // Multiple co-exhibitors: Show simplified title with main exhibitor
            cardTitle.textContent = `${exhibitors[0].name} (+ ${exhibitors.length - 1} more)`;
          }

          // Update search input with location name
          const searchInput = document.getElementById('searchInput');
          searchInput.value = space.name || space.externalId || '';

          // Pre-fill "To" field with destination
          const navToInput = document.getElementById('navToInput');
          navToInput.value = space.name || space.externalId || 'Selected Location';
          navToInput.dataset.spaceId = space.id;

          // Enable tap-to-select mode for "From" location
          const navFromInput = document.getElementById('navFromInput');
          const status = document.getElementById('status');

          status.textContent = '👆 Tap on the map to set your starting location';
          status.style.background = '#14b8a6';
          status.style.display = 'block';

          const selectFromLocation = (event) => {
            if (event.spaces?.length > 0) {
              selectedFromLocation = event.spaces[0];
              navFromInput.value = `📍 ${event.spaces[0].name || event.spaces[0].externalId || 'Location'}`;

              // Auto-trigger directions once both locations are set
              status.textContent = '🧭 Calculating route...';
              status.style.background = '#14b8a6';

              // Trigger directions automatically
              setTimeout(() => {
                document.getElementById('getDirectionsBtn')?.click();
              }, 300);
            }
            mapView.off('click', selectFromLocation);
          };

          mapView.on('click', selectFromLocation);

          // Re-initialize icons for new elements
          if (window.lucide) lucide.createIcons();
        };

        // Setup share button (only show for spaces with booth numbers)
        const shareBtn = document.getElementById('shareBtn');
        if (space.externalId) {
          shareBtn.style.display = 'flex';
          shareBtn.onclick = () => {
            // Create deep-link URL for sharing via SMS/WhatsApp/etc
            const locationName = space.name || space.externalId || 'Location';
            const shareUrl = `${window.location.origin}${window.location.pathname}?booth=${space.externalId}`;
            const shareText = `Check out ${locationName} at the venue: ${shareUrl}`;

            // Copy share text with URL to clipboard (better for SMS/messaging apps)
            navigator.clipboard.writeText(shareText).then(() => {
              status.textContent = '✅ Share link copied! Paste in SMS/WhatsApp';
              status.style.background = '#28a745';
              status.style.display = 'block';
              setTimeout(() => status.style.display = 'none', 3000);
            }).catch(err => {
              // Fallback - show URL
              status.textContent = `📋 Share: ${shareText}`;
              status.style.background = '#14b8a6';
              status.style.display = 'block';
              setTimeout(() => status.style.display = 'none', 5000);
            });
          };
        } else {
          shareBtn.style.display = 'none';  // Hide Share button for non-booth spaces
        }

        // Setup website button (placeholder)
        const websiteBtn = document.getElementById('websiteBtn');
        websiteBtn.onclick = () => {
          status.textContent = '🌐 Exhibitor website would open here';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
        };

        exhibitorCard.classList.add('show');
        mapView.Camera.focusOn(space);

        console.log('📋 Showing card for:', space.name || space.externalId || space.id);
      }

      // Show card for a location object (exhibitor)
      function showCardForLocation(location, showNavigate = false) {
        const cardTitle = document.getElementById('cardTitle');
        const cardSubtitle = document.getElementById('cardSubtitle');
        const cardBooth = document.getElementById('cardBooth');
        const cardDescription = document.getElementById('cardDescription');
        const exhibitorCard = document.getElementById('exhibitorCard');

        // Display exhibitor info from location
        cardTitle.textContent = location.details.name;

        // Show booth number as subtitle
        if (location.details.externalId) {
          cardSubtitle.textContent = `Booth ${location.details.externalId}`;
          cardSubtitle.style.display = 'block';
        } else {
          cardSubtitle.style.display = 'none';
        }

        cardBooth.textContent = `📍 Booth ${location.details.externalId}`;
        cardBooth.style.display = 'inline-block';
        cardDescription.innerHTML = `<p>Exhibitor at booth ${location.details.externalId}</p>`;

        // Show action buttons
        const cardPrimaryActions = document.getElementById('cardPrimaryActions');
        const navigationPanel = document.getElementById('navigationPanel');
        cardPrimaryActions.style.display = 'flex';

        // Setup Directions button
        const directionsBtn = document.getElementById('directionsBtn');
        directionsBtn.onclick = () => {
          navigationPanel.style.display = 'block';
          directionsBtn.style.display = 'none';
          cardDescription.style.display = 'none';

          const navToInput = document.getElementById('navToInput');
          navToInput.value = location.details.name;
          navToInput.dataset.locationId = location.id;

          if (window.lucide) lucide.createIcons();
        };

        exhibitorCard.classList.add('show');
        mapView.Camera.focusOn(location);

        console.log('📋 Showing card for exhibitor:', location.details.name);
      }

      // Display turn-by-turn navigation instructions with accessibility awareness
      function displayNavigationInstructions(directions, startSpace, destination) {
        const cardDescription = document.getElementById('cardDescription');
        const accessModeIcon = accessibleMode ? '♿' : '🚶';
        const accessModeText = accessibleMode ? 'Accessible Route' : 'Standard Route';

        // Connection type icons - using Lucide inline icons
        const connectionIcons = {
          'elevator': '<i data-lucide="move-vertical" style="width:16px;height:16px;display:inline-block;vertical-align:middle;"></i>',
          'escalator': '<i data-lucide="chevrons-up" style="width:16px;height:16px;display:inline-block;vertical-align:middle;"></i>',
          'stairs': '<i data-lucide="arrow-up" style="width:16px;height:16px;display:inline-block;vertical-align:middle;"></i>',
          'ramp': '<i data-lucide="trending-up" style="width:16px;height:16px;display:inline-block;vertical-align:middle;"></i>',
          'door': '<i data-lucide="door-open" style="width:16px;height:16px;display:inline-block;vertical-align:middle;"></i>',
          'portal': '<i data-lucide="circle-dot" style="width:16px;height:16px;display:inline-block;vertical-align:middle;"></i>',
          'shuttle': '<i data-lucide="bus" style="width:16px;height:16px;display:inline-block;vertical-align:middle;"></i>',
          'security': '<i data-lucide="shield" style="width:16px;height:16px;display:inline-block;vertical-align:middle;"></i>'
        };

        let instructionsHTML = `
          <div style="border-top: 2px solid #14b8a6; padding-top: 12px; margin-top: 12px;">
            <h4 style="margin: 0 0 12px 0; color: #14b8a6;">
              ${accessModeIcon} ${accessModeText}
            </h4>
            <div style="margin-bottom: 12px;">
              <strong>📏 Distance:</strong> ${Math.round(directions.distance)}m
              (${Math.round(directions.distance * 3.28)}ft)
            </div>
        `;

        if (directions.instructions && directions.instructions.length > 0) {
          instructionsHTML += `
            <div style="margin: 12px 0;">
              <strong>📋 Turn-by-Turn Directions:</strong>
            </div>
            <ol style="margin: 8px 0; padding-left: 20px;">
          `;

          directions.instructions.forEach((instruction, index) => {
            const action = instruction.action?.type || 'proceed';
            const distance = Math.round(instruction.distance || 0);
            const connection = instruction.connection;

            let iconPrefix = '➡️';
            if (connection?.type) {
              iconPrefix = connectionIcons[connection.type] || '➡️';
            } else if (action.includes('left')) {
              iconPrefix = '⬅️';
            } else if (action.includes('right')) {
              iconPrefix = '➡️';
            }

            instructionsHTML += `
              <li style="margin: 8px 0; line-height: 1.4;">
                ${iconPrefix} <strong>${action}</strong>
                ${distance > 0 ? `<br><span style="color: #666; font-size: 12px;">→ ${distance}m ahead</span>` : ''}
                ${connection ? `<br><span style="color: #14b8a6; font-size: 12px;">→ Use ${connection.type}</span>` : ''}
              </li>
            `;
          });

          instructionsHTML += '</ol>';
        }

        instructionsHTML += `
          <div style="margin-top: 12px; padding: 8px; background: ${accessibleMode ? '#e8f5e9' : '#f5f5f5'}; border-radius: 4px; font-size: 12px;">
            ${accessibleMode ?
              '✅ This route avoids stairs and uses elevators/ramps' :
              'ℹ️ This route may include stairs. Enable ♿ Accessible mode for elevator/ramp routes.'}
          </div>
        </div>
        `;

        cardDescription.innerHTML += instructionsHTML;

        console.log('📍 Navigation instructions displayed in exhibitor card');
      }

      // Navigate to a space (with directions) - Accessible-Aware Navigation
      async function navigateToSpace(destination) {
        try {
          const accessModeText = accessibleMode ? '♿ accessible' : 'standard';
          status.textContent = `🧭 Calculating ${accessModeText} route to ${destination.name || destination.externalId}...`;
          status.style.background = '#14b8a6';
          status.style.display = 'block';

          // For POC: Use first entrance of a random nearby space as starting point
          // In production: Use BlueDot for actual user location
          const allSpaces = mapData.getByType('space');
          const startSpace = allSpaces[Math.floor(Math.random() * Math.min(10, allSpaces.length))];

          // Get directions using official Mappedin API with accessibility option
          const directions = await mapData.getDirections(startSpace, destination, {
            accessible: accessibleMode  // ✅ Use accessibility state
          });

          if (directions) {
            console.log('📍 Navigation Details:');
            console.log('- Distance:', directions.distance, 'meters');
            console.log('- Accessible mode:', accessibleMode);
            console.log('- Instructions:', directions.instructions?.length || 0, 'steps');

            // Use official Navigation.draw() method (exactly like docs)
            mapView.Navigation.draw(directions, {
              pathOptions: {
                displayArrowsOnPath: true,
                animateArrowsOnPath: true
              }
            });

            // Display turn-by-turn instructions UI
            displayNavigationInstructions(directions, startSpace, destination);

            // Focus on destination
            mapView.Camera.focusOn(destination);

            status.textContent = `✅ Route shown! Distance: ${Math.round(directions.distance)}m`;
            status.style.background = '#28a745';

            // Show clear path button after navigation is drawn
            const clearPathBtn = document.getElementById('clearPathBtn');
            if (clearPathBtn) clearPathBtn.style.display = 'flex';

            setTimeout(() => status.style.display = 'none', 5000);

            console.log('🧭 Navigation route displayed:', {
              from: startSpace.name,
              to: destination.name || destination.externalId,
              distance: directions.distance,
              instructions: directions.instructions?.length || 0
            });

            // Log turn-by-turn instructions if available
            if (directions.instructions) {
              console.log('📋 Turn-by-turn instructions:');
              directions.instructions.forEach((instruction, index) => {
                console.log(`${index + 1}. ${instruction.action?.type} - ${Math.round(instruction.distance)}m`);
              });
            }
          } else {
            status.textContent = '⚠️ Could not calculate route';
            status.style.background = '#ff9800';
            setTimeout(() => status.style.display = 'none', 3000);
          }
        } catch (error) {
          console.error('Navigation error:', error);
          status.textContent = `❌ Navigation error: ${error.message}`;
          status.style.background = '#dc3545';
          setTimeout(() => status.style.display = 'none', 3000);
        }
      }

      // Drop Pin
      function setupDropPin() {
        let dropPinMode = false;
        let dropPinMarker = null;
        const pinIndicator = document.getElementById('pinIndicator');

        // Zoom controls
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');

        if (zoomInBtn) {
          zoomInBtn.addEventListener('click', () => {
            const currentZoom = mapView.Camera.zoom;
            mapView.Camera.set({ zoom: currentZoom * 1.3, animationDuration: 300 });
          });
        }

        if (zoomOutBtn) {
          zoomOutBtn.addEventListener('click', () => {
            const currentZoom = mapView.Camera.zoom;
            mapView.Camera.set({ zoom: currentZoom * 0.77, animationDuration: 300 });
          });
        }

        // Compact drop pin button handler (new compact modal)
        const compactDropBtn = document.getElementById('dropPinBtnCompact');
        if (compactDropBtn) {
          compactDropBtn.addEventListener('click', () => {
            dropPinMode = !dropPinMode;
            compactDropBtn.classList.toggle('active', dropPinMode);
            status.textContent = dropPinMode ? '🪂 Click map to drop pin!' : 'Drop pin disabled';
            status.style.display = 'block';
            if (!dropPinMode) setTimeout(() => status.style.display = 'none', 2000);
          });
        }

        // Original drop pin button handler
        document.getElementById('dropPinBtn').addEventListener('click', () => {
          dropPinMode = !dropPinMode;
          document.getElementById('dropPinBtn').classList.toggle('active', dropPinMode);
          status.textContent = dropPinMode ? '🪂 Click map to drop pin!' : 'Drop pin disabled';
          status.style.display = 'block';
          if (!dropPinMode) setTimeout(() => status.style.display = 'none', 2000);
        });

        mapView.on('click', (event) => {
          if (dropPinMode && event.coordinate) {
            if (dropPinMarker) mapView.Markers.remove(dropPinMarker);

            const pinHTML = `<div style="position:relative;width:40px;height:80px;"><div style="position:absolute;top:0;left:50%;transform:translateX(-50%);font-size:32px;animation:parachuteFloat 1.2s ease-out forwards;">🪂</div><div style="position:absolute;bottom:0;left:50%;transform:translateX(-50%);font-size:42px;animation:pinDrop 1.2s ease-out;">📍</div></div>`;

            dropPinMarker = mapView.Markers.add(event.coordinate, pinHTML, { anchor: 'bottom', rank: 5 });
            dropPinMode = false;
            document.getElementById('dropPinBtn').classList.remove('active');
            if (compactDropBtn) compactDropBtn.classList.remove('active');

            // Show pin indicator in compact modal
            if (pinIndicator) {
              pinIndicator.classList.add('active');
            }

            status.textContent = '📍 Pin dropped!';
            setTimeout(() => status.style.display = 'none', 2000);
          }
        });
      }

      // Accessibility Toggle
      function setupAccessibility() {
        const toggle = document.getElementById('accessibilityToggle');
        const navToggle = document.getElementById('navAccessibleToggle');
        const navStatus = document.getElementById('navAccessibleStatus');

        // Sync both toggles with global state
        function updateAccessibleState(newState) {
          accessibleMode = newState;

          // Update main toggle button
          toggle.classList.toggle('active', accessibleMode);

          // Update navigation panel checkbox
          if (navToggle) {
            navToggle.checked = accessibleMode;
          }

          // Update navigation panel status text
          if (navStatus) {
            if (accessibleMode) {
              navStatus.textContent = '♿ Prefers elevators and ramps';
              navStatus.style.color = '#28a745';
            } else {
              navStatus.textContent = '🚶 All routes (may include stairs)';
              navStatus.style.color = '#666';
            }
          }
        }

        // Compact toggle button handler (new compact modal)
        const compactToggle = document.getElementById('accessibilityToggleCompact');
        if (compactToggle) {
          compactToggle.addEventListener('click', () => {
            updateAccessibleState(!accessibleMode);
            compactToggle.classList.toggle('active', accessibleMode);

            if (accessibleMode) {
              status.textContent = '♿ Accessible mode: ON (prefers elevators)';
              console.log('♿ Accessible navigation enabled');
            } else {
              status.textContent = '🚶 Accessible mode: OFF (all routes)';
            }
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 2000);
          });
        }

        // Main toggle button handler
        toggle.addEventListener('click', () => {
          updateAccessibleState(!accessibleMode);

          if (accessibleMode) {
            status.textContent = '♿ Accessible mode: ON (prefers elevators)';
            console.log('♿ Accessible navigation enabled');
          } else {
            status.textContent = '🚶 Accessible mode: OFF (all routes)';
            console.log('🚶 Standard navigation enabled');
          }

          status.style.background = '#14b8a6';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
        });

        // Navigation panel checkbox handler
        if (navToggle) {
          navToggle.addEventListener('change', (e) => {
            updateAccessibleState(e.target.checked);

            console.log(`♿ Accessible mode ${accessibleMode ? 'enabled' : 'disabled'} from navigation panel`);
          });
        }

        console.log('✅ Accessibility toggle initialized (default: ON)');
      }


      // Search with Autocomplete
      // Initialize modular search system
      let searchUI;

      function setupSearch() {
        // Create search instance
        const searchInstance = new MappedInSearch(mapData, {
          debounceDelay: 200,
          maxSuggestions: 6,
          searchBoothNumbers: true
        });

        // Create UI manager
        searchUI = new SearchUIManager(searchInstance, mapView, {
          inputSelector: '#searchInput',
          suggestionsSelector: '#searchSuggestions',
          onSelect: (suggestion) => {
            // Suggestion has a 'node' property with the actual map object
            const node = suggestion.node;
            if (!node) {
              console.warn('No node found for suggestion:', suggestion);
              return;
            }

            // Check if it's a location (has details.name) or a space
            if (node.details && node.details.name) {
              showCardForLocation(node, true);
            } else if (node.name || node.id) {
              showCardForSpace(node, true);
            } else {
              console.log('Selected:', node);
            }
          }
        });

        console.log('✅ Modular search initialized (debounced 200ms, Enter key support, booth numbers enabled)');
      }

      // Floor and zoom controls removed - using inline floor selector and compact modal zoom buttons instead

      // NOTE: Search suggestion and selection logic now handled by search-module.js
      // The MappedInSearch and SearchUIManager classes provide:
      // - getSuggestions() - Get autocomplete suggestions
      // - searchBoothNumbers() - Search by externalId
      // - buildSuggestionsHTML() - Build dropdown HTML
      // - focusOnSuggestion() - Focus camera and show card
      //
      // This modular approach makes the search system:
      // - Reusable across HTML and React versions
      // - Easier to test and maintain
      // - More organized and readable

      // Navigation Panel Handlers
      let selectedFromLocation = null;

      // Pin drop for "From" location
      document.getElementById('fromPinIcon')?.addEventListener('click', () => {
        const navFromInput = document.getElementById('navFromInput');
        status.textContent = '📍 Click on map to set starting location';
        status.style.background = '#14b8a6';
        status.style.display = 'block';

        // Enable one-time click to set from location
        const setFromLocation = (event) => {
          if (event.coordinate) {
            selectedFromLocation = event.coordinate;
            navFromInput.value = `📍 Pin location (${event.coordinate.latitude.toFixed(4)}, ${event.coordinate.longitude.toFixed(4)})`;
            status.textContent = '✅ Starting location set';
            status.style.background = '#28a745';
            setTimeout(() => status.style.display = 'none', 2000);
          } else if (event.spaces?.length > 0) {
            selectedFromLocation = event.spaces[0];
            navFromInput.value = `📍 ${event.spaces[0].name || event.spaces[0].externalId || 'Location'}`;
            status.textContent = '✅ Starting location set';
            status.style.background = '#28a745';
            setTimeout(() => status.style.display = 'none', 2000);
          }
          mapView.off('click', setFromLocation);
        };

        mapView.on('click', setFromLocation);
      });

      // Search functionality for "From" field
      const navFromInput = document.getElementById('navFromInput');
      let fromSearchTimeout;

      navFromInput?.addEventListener('input', async (e) => {
        clearTimeout(fromSearchTimeout);
        const query = e.target.value.trim();

        if (query.length < 2) {
          return;
        }

        // Debounce search
        fromSearchTimeout = setTimeout(async () => {
          try {
            // Use suggest() API for "From" field
            let suggestions = await mapData.Search.suggest(query, {
              enterpriseLocations: { enabled: true },
              places: { enabled: true }
            });

            // Also search booth numbers manually
            const queryUpper = query.toUpperCase();
            const spacesWithIds = mapData.getByType('space').filter(s =>
              s.externalId && s.externalId.toUpperCase().includes(queryUpper)
            );

            // Add booth number matches to suggestions
            if (spacesWithIds.length > 0) {
              const boothSuggestions = spacesWithIds.slice(0, 3).map(space => ({
                name: `Booth ${space.externalId}`,
                value: space.externalId,
                type: 'booth',
                node: space
              }));

              suggestions = [...boothSuggestions, ...(suggestions || [])];
            }

            // If we have results, auto-select first one
            if (suggestions && suggestions.length > 0) {
              const firstResult = suggestions[0];
              if (firstResult.node) {
                selectedFromLocation = firstResult.node;
                navFromInput.value = firstResult.name || firstResult.value || 'Selected Location';
                navFromInput.dataset.spaceId = firstResult.node.id;
              }
            }
          } catch (error) {
            console.error('From field search error:', error);
          }
        }, 300);
      });

      // Get Directions button
      document.getElementById('getDirectionsBtn')?.addEventListener('click', async () => {
        const navToInput = document.getElementById('navToInput');
        const destinationSpaceId = navToInput.dataset.spaceId;

        if (!selectedFromLocation) {
          status.textContent = '⚠️ Please select a starting location';
          status.style.background = '#ff9800';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
          return;
        }

        // Get destination space
        const allSpaces = mapData.getByType('space');
        const destination = allSpaces.find(s => s.id === destinationSpaceId);

        if (!destination) {
          status.textContent = '⚠️ Destination not found';
          status.style.background = '#dc3545';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);
          return;
        }

        try {
          // Get directions with accessibility mode
          const directions = await mapData.getDirections(selectedFromLocation, destination, {
            accessible: accessibleMode
          });

          // Draw the path on the map
          mapView.Navigation.draw(directions, {
            pathOptions: {
              nearRadius: 1.5,
              farRadius: 0.8,
              color: '#14b8a6'
            },
            animatedPathOptions: {
              color: '#14b8a6',
              animationDuration: 2000
            }
          });

          // Shrink card to compact mode - hide everything except To/From fields
          const exhibitorCard = document.getElementById('exhibitorCard');
          const cardDescription = document.getElementById('cardDescription');
          const cardPrimaryActions = document.getElementById('cardPrimaryActions');

          // Just hide content, let responsive CSS handle sizing
          cardDescription.style.display = 'none';
          cardPrimaryActions.style.display = 'none';

          // Show Clear Path button
          document.getElementById('clearPathBtn').style.display = 'block';

          // Show turn-by-turn section
          const turnByTurnSection = document.getElementById('turnByTurnSection');
          turnByTurnSection.style.display = 'block';

          // Build turn-by-turn instructions
          buildTurnByTurnInstructions(directions);

          // Zoom camera to show entire path
          if (directions.path && directions.path.length > 0) {
            // Get all nodes in the path
            const pathNodes = directions.path;

            // Focus camera on the path to show the entire route
            mapView.Camera.focusOn(pathNodes, {
              minZoom: 1000,
              maxZoom: 3000,
              animationDuration: 800
            });
          }

          // Re-initialize icons
          if (window.lucide) lucide.createIcons();

          status.textContent = `✅ Route calculated (${directions.distance.toFixed(0)}m)`;
          status.style.background = '#28a745';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 2000);

        } catch (error) {
          console.error('Navigation error:', error);
          status.textContent = `❌ Navigation error: ${error.message}`;
          status.style.background = '#dc3545';
          status.style.display = 'block';
          setTimeout(() => status.style.display = 'none', 3000);
        }
      });

      // Clear Path button
      document.getElementById('clearPathBtn')?.addEventListener('click', () => {
        mapView.Navigation.clear();
        document.getElementById('clearPathBtn').style.display = 'none';
        document.getElementById('turnByTurnSection').style.display = 'none';

        // Restore Directions button and description visibility
        document.getElementById('directionsBtn').style.display = 'flex';
        document.getElementById('cardPrimaryActions').style.display = 'flex';

        const cardDescription = document.getElementById('cardDescription');
        const cardTitle = document.getElementById('cardTitle');

        cardDescription.style.display = 'block';

        // Restore original title and description if they were modified
        if (cardTitle.dataset.originalContent) {
          cardTitle.textContent = cardTitle.dataset.originalContent;
          delete cardTitle.dataset.originalContent;
        }
        if (cardDescription.dataset.originalContent) {
          cardDescription.innerHTML = cardDescription.dataset.originalContent;
          delete cardDescription.dataset.originalContent;
        }

        status.textContent = '✅ Path cleared';
        status.style.background = '#28a745';
        status.style.display = 'block';
        setTimeout(() => status.style.display = 'none', 2000);
      });

      // Turn-by-Turn toggle
      document.getElementById('toggleTurnByTurn')?.addEventListener('click', () => {
        const content = document.getElementById('turnByTurnContent');
        const chevron = document.getElementById('turnByTurnChevron');

        if (content.style.display === 'none') {
          content.style.display = 'block';
          chevron.style.transform = 'rotate(180deg)';
        } else {
          content.style.display = 'none';
          chevron.style.transform = 'rotate(0deg)';
        }
      });

      // Build turn-by-turn instructions using DirectionsCard component
      function buildTurnByTurnInstructions(directions) {
        const turnByTurnContent = document.getElementById('turnByTurnContent');

        // Use the DirectionsCard component for improved UI
        const directionsCard = new DirectionsCard({
          accessibleMode: accessibleMode,
          onStepClick: (instruction, index) => {
            // Focus camera on the instruction location
            if (instruction.coordinate) {
              mapView.Camera.focusOn({
                nodes: [instruction],
                minZoom: 800,
                maxZoom: 1500,
                animationDuration: 600
              });
            }
          }
        });

        // Render just the instructions section (not the full card)
        const instructionsHTML = directionsCard.buildRouteInfo(directions,
          accessibleMode ? '♿' : '🚶',
          accessibleMode ? 'Accessible Route' : 'Standard Route'
        ) + directionsCard.buildInstructions(directions.instructions);

        turnByTurnContent.innerHTML = instructionsHTML;

        // Attach click handlers to steps
        const steps = turnByTurnContent.querySelectorAll('.step');
        steps.forEach((step, index) => {
          step.addEventListener('click', () => {
            const instruction = directions.instructions[index];

            // Visual feedback - highlight clicked step
            steps.forEach(s => s.classList.remove('step--active'));
            step.classList.add('step--active');

            if (instruction.coordinate) {
              // Focus camera on this step's location
              console.log(`📍 Focusing on step ${index + 1}:`, instruction);
              mapView.Camera.set({
                center: { x: instruction.coordinate[0], y: instruction.coordinate[1] },
                zoom: 1200,
                tilt: 0,
                rotation: 0,
                animationDuration: 600
              });
            } else {
              console.warn(`⚠️ Step ${index + 1} has no coordinate`, instruction);
            }
          });
        });
      }

      // Floating Filter Buttons
      console.log('🔧 Setting up floating filter buttons...');

      // Amenities Toggle (includes restrooms and rooms)
      const amenitiesBtn = document.getElementById('amenitiesToggle');
      console.log('Amenities button found:', amenitiesBtn);

      if (amenitiesBtn) {
        amenitiesBtn.addEventListener('click', function() {
          console.log('🎯 Amenities button clicked!');
          this.classList.toggle('active');
          const isActive = this.classList.contains('active');

          // Toggle all amenity categories
          categoryMarkers.amenities.forEach(marker => {
            marker.visible = isActive;
          });
          categoryMarkers.restrooms.forEach(marker => {
            marker.visible = isActive;
          });
          categoryMarkers.rooms.forEach(marker => {
            marker.visible = isActive;
          });

          const totalAmenities = categoryMarkers.amenities.length +
                                categoryMarkers.restrooms.length +
                                categoryMarkers.rooms.length;

          console.log(`${isActive ? '✅ Showing' : '❌ Hiding'} amenities (${totalAmenities} total: ${categoryMarkers.amenities.length} general, ${categoryMarkers.restrooms.length} restrooms, ${categoryMarkers.rooms.length} rooms)`);
        });
      }

      // Exhibitors Toggle
      const exhibitorsBtn = document.getElementById('exhibitorsToggle');
      console.log('Exhibitors button found:', exhibitorsBtn);

      if (exhibitorsBtn) {
        exhibitorsBtn.addEventListener('click', function() {
          console.log('🎯 Exhibitors button clicked!');
          this.classList.toggle('active');
          const isActive = this.classList.contains('active');

          // Toggle all exhibitor markers
          exhibitorMarkers.forEach(marker => {
            marker.visible = isActive;
          });

          console.log(`${isActive ? '✅ Showing' : '❌ Hiding'} exhibitors (${exhibitorMarkers.length} markers)`);
        });
      }

      // Close card
      document.getElementById('closeCard')?.addEventListener('click', () => {
        const exhibitorCard = document.getElementById('exhibitorCard');
        exhibitorCard.classList.remove('show');
        document.getElementById('navigationPanel').style.display = 'none';

        // Restore Directions button and description visibility
        const directionsBtn = document.getElementById('directionsBtn');
        if (directionsBtn) directionsBtn.style.display = 'flex';

        const cardDescription = document.getElementById('cardDescription');
        const cardTitle = document.getElementById('cardTitle');

        if (cardDescription) cardDescription.style.display = 'block';

        // Restore original title and description if they were modified
        if (cardTitle && cardTitle.dataset.originalContent) {
          cardTitle.textContent = cardTitle.dataset.originalContent;
          delete cardTitle.dataset.originalContent;
        }
        if (cardDescription && cardDescription.dataset.originalContent) {
          cardDescription.innerHTML = cardDescription.dataset.originalContent;
          delete cardDescription.dataset.originalContent;
        }

        // Clear search input
        const searchInput = document.getElementById('searchInput');
        if (searchInput) searchInput.value = '';
      });
    });
  </script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body, html {
      width: 100%;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      position: fixed;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-x pan-y;
    }

    /* Prevent pull-to-refresh on mobile */
    body {
      overscroll-behavior: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
    }

    /* Touch-friendly interactive elements */
    button, a, input, select, .clickable {
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
      touch-action: manipulation;
      min-height: 44px; /* iOS Human Interface Guidelines minimum */
      min-width: 44px;
    }

    /* Prevent text selection on touch */
    * {
      -webkit-user-select: none;
      user-select: none;
    }

    /* Allow text selection in inputs */
    input, textarea {
      -webkit-user-select: text;
      user-select: text;
    }

    #mappedin-map {
      width: 100%;
      height: 100%;
      touch-action: pan-x pan-y pinch-zoom;
    }

    /* Search Bar - Always Visible */
    .search-container {
      position: absolute;
      top: 16px;
      left: 16px;
      right: 16px;
      z-index: 100;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .search-input-wrapper {
      flex: 1;
      position: relative;
    }

    #searchInput {
      width: 100%;
      padding: 12px 16px;
      border: none;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.2);
      font-size: 14px;
      outline: none;
    }

    /* Search Suggestions Dropdown */
    .search-suggestions {
      display: none;
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
    }

    .search-suggestion {
      padding: 14px 16px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      transition: background 0.15s;
      -webkit-tap-highlight-color: transparent;
      min-height: 60px;
      display: flex;
      align-items: center;
      user-select: none;
      -webkit-user-select: none;
    }

    .search-suggestion:last-child {
      border-bottom: none;
    }

    .search-suggestion:hover,
    .search-suggestion:active {
      background: #f8f9fa;
    }

    /* Better touch feedback for mobile */
    @media (hover: none) {
      .search-suggestion:active {
        background: #e8eaed;
        transform: scale(0.98);
      }
    }

    .suggestion-name {
      font-size: 14px;
      font-weight: 500;
      color: #333;
      margin-bottom: 4px;
    }

    .suggestion-type {
      font-size: 12px;
      color: #999;
    }

    #status {
      position: absolute;
      top: 130px; /* Move below search on mobile */
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 12px 24px;
      border-radius: 12px;
      z-index: 100;
      font-size: 14px;
    }

    /* Right Controls - Hidden on new layout */
    .controls {
      display: none;
    }

    /* Floor Selector - Inline with search */
    .floor-selector {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.2); /* Match search bar shadow */
      padding: 12px 12px; /* Match search bar padding height */
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
      height: 44px; /* Match search input height */
      box-sizing: border-box;
    }

    .floor-label {
      display: none; /* Hide floor label */
    }

    .floor-selector select {
      border: none;
      background: transparent; /* Remove background for cleaner look */
      border-radius: 0;
      padding: 0;
      font-size: 14px;
      font-weight: 500;
      color: #1a1a1a;
      cursor: pointer;
      font-family: inherit;
      transition: color 0.2s ease;
      outline: none;
      min-width: 60px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      -webkit-appearance: none;
      appearance: none;
    }

    .floor-selector select:hover {
      color: #14b8a6;
    }

    .floor-selector select:focus {
      color: #14b8a6;
    }

    .floor-icon {
      font-size: 18px;
      line-height: 1;
      opacity: 0.8;
      flex-shrink: 0;
    }

    /* New Compact Modal - Lower on screen */
    .compact-modal {
      position: fixed;
      bottom: 150px;
      right: 12px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      padding: 8px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 48px;
    }

    .compact-btn {
      width: 44px;
      height: 44px;
      border: none;
      background: #f3f3f5;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      color: #666;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      position: relative;
    }

    .compact-btn:hover {
      background: #e9e9ee;
    }

    .compact-btn.active {
      background: #14b8a6;
      color: white;
    }

    .compact-btn.active:hover {
      background: #0d9488;
    }

    .pin-indicator {
      width: 44px;
      height: 44px;
      background: #f8f9fa;
      border-radius: 10px;
      display: none;
      align-items: center;
      justify-content: center;
      color: #14b8a6;
      font-size: 11px;
      font-weight: 600;
      text-align: center;
      line-height: 1.2;
      padding: 4px;
    }

    .pin-indicator.active {
      display: flex;
    }

    /* Control Group - Hidden */
    .control-group {
      display: none;
    }

    .control-title {
      display: none;
    }

    .toggle-btn {
      width: 100%;
      padding: 8px 10px;
      min-height: 40px;
      border: none;
      border-radius: 8px;
      background: #f0f0f0;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: #333;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin-bottom: 6px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .toggle-btn:last-child {
      margin-bottom: 0;
    }

    .toggle-btn:hover,
    .toggle-btn:active {
      background: #e0e0e0;
    }

    .toggle-btn.active {
      background: #14b8a6;
      color: white;
    }

    .toggle-btn.active:hover,
    .toggle-btn.active:active {
      background: #0d9488;
    }

    /* Floating Toggle Buttons */
    .floating-toggle {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 72px;
      height: 72px;
      min-width: 44px;
      min-height: 44px;
      background: white;
      border: 2px solid #ddd;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      pointer-events: auto;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
    }

    .floating-toggle:hover,
    .floating-toggle:active {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      border-color: #14b8a6;
    }

    .floating-toggle.active {
      background: #14b8a6;
      color: white;
      border-color: #14b8a6;
    }

    .floating-toggle.active:hover,
    .floating-toggle.active:active {
      background: #0d9488;
    }

    /* Better touch feedback */
    @media (hover: none) {
      .floating-toggle:active {
        transform: scale(0.95);
      }
    }

    /* Exhibitor Card */
    #exhibitorCard {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%) translateY(400px);
      width: calc(100% - 32px);
      max-width: 420px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.2);
      padding: 16px;
      z-index: 200;
      transition: transform 0.3s ease-out, padding 0.3s ease-out;
    }

    #exhibitorCard.show {
      transform: translateX(-50%) translateY(0);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .card-title {
      font-size: 16px;
      font-weight: 600;
      color: #1a1a1a;
      line-height: 1.3;
      margin-bottom: 4px;
    }

    .card-subtitle {
      font-size: 13px;
      color: #666;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .card-booth {
      display: inline-block;
      background: #14b8a6;
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      margin-top: 4px;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 28px;
      cursor: pointer;
      color: #999;
      padding: 8px;
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      border-radius: 50%;
      transition: background 0.2s;
    }

    .close-btn:hover,
    .close-btn:active {
      background: #f0f0f0;
      color: #333;
    }

    .card-description {
      color: #666;
      font-size: 14px;
      margin-bottom: 12px;
    }

    .card-categories {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .card-actions {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    .action-btn {
      flex: 1;
      padding: 12px 16px;
      min-height: 44px;
      border: none;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .action-btn:hover,
    .action-btn:active {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .action-btn.primary {
      background: linear-gradient(135deg, #14b8a6 0%, #06b6d4 100%);
      color: white;
    }

    .action-btn.secondary {
      background: #f0f0f0;
      color: #333;
    }

    /* Primary Action Buttons - Wide Outline Style */
    .card-primary-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e0e0e0;
    }

    .action-btn-wide {
      width: 100%;
      padding: 14px 20px;
      min-height: 48px;
      border-radius: 10px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
    }

    .action-btn-wide.outline {
      background: transparent;
      border: 2px solid #14b8a6;
      color: #14b8a6;
    }

    .action-btn-wide.outline:hover,
    .action-btn-wide.outline:active {
      background: #14b8a6;
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    /* Mobile-specific touch feedback */
    @media (hover: none) {
      .action-btn-wide.outline:active {
        transform: scale(0.98);
      }
    }

    /* Hide Mappedin Watermark (WARNING: May violate terms of service) */
    /* Only use if you have proper licensing/permission from Mappedin */
    /*
    .mappedin-watermark,
    [class*="watermark"],
    [class*="attribution"] {
      display: none !important;
      opacity: 0 !important;
      visibility: hidden !important;
    }
    */

    @keyframes parachuteFloat {
      0% { transform: translateX(-50%) translateY(-120px); opacity: 0; }
      40% { opacity: 1; }
      70% { opacity: 1; }
      100% { transform: translateX(-50%) translateY(-30px); opacity: 0; }
    }

    @keyframes pinDrop {
      0% { transform: translateX(-50%) translateY(-120px); opacity: 0; }
      60% { transform: translateX(-50%) translateY(5px); }
      75% { transform: translateX(-50%) translateY(-3px); }
      100% { transform: translateX(-50%) translateY(0); opacity: 1; }
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      .search-container {
        top: 12px;
        left: 12px;
        right: 12px;
        gap: 8px;
      }

      .search-input-wrapper {
        flex: 1;
      }

      #searchInput {
        padding: 10px 14px;
        padding-left: 40px;
        font-size: 14px;
      }

      .floor-selector {
        padding: 10px;
        height: 44px;
      }

      .floor-icon {
        display: none; /* Hide icon on mobile */
      }

      .floor-selector select {
        min-width: 80px;
      }

      .compact-modal {
        bottom: 140px;
        right: 12px;
      }

      .compact-btn {
        width: 40px;
        height: 40px;
      }

      .pin-indicator {
        width: 40px;
        height: 40px;
        font-size: 10px;
      }

      #exhibitorCard {
        bottom: 100px; /* Lower on mobile */
        width: calc(100% - 32px);
        max-width: 380px; /* Scale down - more compact */
        padding: 12px;
        border-radius: 10px;
      }

      #exhibitorCard.show {
        transform: translateX(-50%) translateY(0);
      }

      .card-title {
        font-size: 14px;
      }

      .card-subtitle {
        font-size: 12px;
      }

      .card-booth {
        font-size: 11px;
        padding: 3px 8px;
      }

      .card-description {
        font-size: 13px;
      }

      #navigationPanel {
        padding: 10px;
      }

      .action-btn-wide {
        padding: 10px 14px;
        font-size: 13px;
      }
    }

    /* iPhone and small mobile devices */
    @media (max-width: 390px) {
      .search-container {
        top: 10px;
        left: 10px;
        right: 10px; /* Full width for flex layout */
        gap: 6px;
      }

      #searchInput {
        font-size: 13px;
        padding: 10px 10px 10px 42px;
      }

      #exhibitorCard {
        bottom: 90px; /* Lower on small mobile */
        width: calc(100% - 24px);
        max-width: 350px;
        padding: 11px;
      }

      #exhibitorCard.show {
        transform: translateX(-50%) translateY(0);
      }

      .card-title {
        font-size: 14px;
      }

      /* Floor selector inline - compact on small screens */
      .floor-selector {
        padding: 5px 8px;
        gap: 4px;
      }

      .floor-btn {
        width: 28px;
        height: 28px;
        font-size: 16px;
      }

      .floor-current {
        font-size: 11px;
        padding: 3px 6px;
        min-width: 40px;
      }

      /* Compact modal */
      .compact-modal {
        bottom: 130px;
        right: 10px;
        padding: 6px;
        gap: 5px;
      }

      .compact-btn {
        width: 42px;
        height: 42px;
      }

      .pin-indicator {
        width: 42px;
        height: 42px;
      }

      /* Floating filter buttons */
      .floating-toggle {
        padding: 8px 12px;
      }

      .floating-toggle i {
        width: 20px !important;
        height: 20px !important;
      }

      .floating-toggle span {
        font-size: 11px !important;
      }
    }
  </style>
</head>
<body>
  <div id="mappedin-map"></div>

  <!-- Top Row: Search Bar + Floor Selector -->
  <div class="search-container">
    <!-- Search Input -->
    <div class="search-input-wrapper">
      <i data-lucide="search" style="position: absolute; left: 16px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; color: #999;"></i>
      <input type="text" id="searchInput" placeholder="Search exhibitors..." style="padding-left: 44px;">

      <!-- Search Suggestions Dropdown -->
      <div id="searchSuggestions" class="search-suggestions"></div>
    </div>

    <!-- Floor Selector - Inline -->
    <div class="floor-selector" id="floorSelectorContainer">
      <i data-lucide="layers" class="floor-icon"></i>
      <select id="floorSelect">
        <option>Loading...</option>
      </select>
    </div>
  </div>

  <div id="status">Initializing...</div>

  <!-- Right Side Controls -->
  <div class="controls">
    <!-- Controls Group -->
    <div class="control-group">
      <div class="control-title">Controls</div>
      <button class="toggle-btn active" id="accessibilityToggle">
        <i data-lucide="accessibility" style="width: 18px; height: 18px;"></i>
        <span>Accessible</span>
      </button>
      <button class="toggle-btn" id="dropPinBtn">
        <i data-lucide="map-pin" style="width: 18px; height: 18px;"></i>
        <span>Drop Pin</span>
      </button>
    </div>

    <!-- Floating Filter Buttons (Bottom Center) -->
    <div style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 16px; z-index: 100; pointer-events: none;">
      <!-- Amenities Toggle -->
      <button id="amenitiesToggle" class="floating-toggle" title="Toggle Amenities">
        <i data-lucide="building-2" style="width: 32px; height: 32px;"></i>
      </button>

      <!-- Exhibitors Toggle -->
      <button id="exhibitorsToggle" class="floating-toggle active" title="Toggle Exhibitors">
        <i data-lucide="store" style="width: 32px; height: 32px;"></i>
      </button>
    </div>
  </div>

  <!-- Compact Modal - Lower right -->
  <div class="compact-modal">
    <!-- Zoom In Button -->
    <button class="compact-btn" id="zoomInBtn" title="Zoom in">
      <i data-lucide="plus" style="width: 22px; height: 22px;"></i>
    </button>

    <!-- Zoom Out Button -->
    <button class="compact-btn" id="zoomOutBtn" title="Zoom out">
      <i data-lucide="minus" style="width: 22px; height: 22px;"></i>
    </button>

    <!-- Accessible Toggle -->
    <button class="compact-btn active" id="accessibilityToggleCompact" title="Accessible mode (elevators/ramps)">
      <i data-lucide="accessibility" style="width: 22px; height: 22px;"></i>
    </button>

    <!-- Pin Location Indicator -->
    <div class="pin-indicator" id="pinIndicator">
      <i data-lucide="map-pin" style="width: 20px; height: 20px;"></i>
    </div>

    <!-- Drop Pin Button -->
    <button class="compact-btn" id="dropPinBtnCompact" title="Drop pin on map">
      <i data-lucide="map-pin" style="width: 22px; height: 22px;"></i>
    </button>
  </div>

  <!-- Exhibitor Card -->
  <div id="exhibitorCard">
    <div class="card-header">
      <div>
        <div class="card-title" id="cardTitle">Exhibitor</div>
        <div class="card-subtitle" id="cardSubtitle" style="display: none;">Booth Number</div>
        <div class="card-booth" id="cardBooth">Booth</div>
      </div>
      <button class="close-btn" id="closeCard">×</button>
    </div>

    <!-- Primary Actions at Top -->
    <div class="card-primary-actions" id="cardPrimaryActions" style="display:none;">
      <button class="action-btn-wide outline" id="directionsBtn">
        <i data-lucide="navigation" style="width: 18px; height: 18px; margin-right: 8px;"></i>
        Directions
      </button>
      <button class="action-btn-wide outline" id="shareBtn">
        <i data-lucide="share-2" style="width: 18px; height: 18px; margin-right: 8px;"></i>
        Share URL
      </button>
    </div>

    <!-- Navigation Panel (shown when Directions clicked) -->
    <div id="navigationPanel" style="display:none; margin-bottom: 12px; padding: 12px; background: #f8f9fa; border-radius: 8px;">
      <!-- To/From Fields -->
      <div style="margin-bottom: 10px;">
        <label style="display: block; font-size: 11px; color: #666; margin-bottom: 4px; font-weight: 500;">To:</label>
        <input type="text" id="navToInput" readonly style="width: 100%; padding: 10px 12px; border: 1px solid #ddd; border-radius: 8px; background: #e9ecef; color: #333; font-size: 13px;">
      </div>

      <div style="margin-bottom: 10px;">
        <label style="display: block; font-size: 11px; color: #666; margin-bottom: 4px; font-weight: 500;">From:</label>
        <div style="position: relative;">
          <i data-lucide="search" style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); width: 16px; height: 16px; color: #999;"></i>
          <input type="text" id="navFromInput" placeholder="Search location or drop pin..." style="width: 100%; padding: 10px 36px 10px 36px; border: 1px solid #ddd; border-radius: 8px; font-size: 13px;">
          <i data-lucide="map-pin" id="fromPinIcon" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); width: 16px; height: 16px; color: #14b8a6; cursor: pointer;" title="Drop pin on map"></i>
        </div>
      </div>

      <!-- Accessible Mode Toggle -->
      <div style="margin-bottom: 10px; padding: 8px 10px; background: white; border-radius: 6px; border: 1px solid #ddd;">
        <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; user-select: none;">
          <div style="display: flex; align-items: center; gap: 6px;">
            <i data-lucide="accessibility" style="width: 16px; height: 16px; color: #14b8a6;"></i>
            <span style="font-size: 13px; color: #333;">Accessible Route</span>
          </div>
          <input type="checkbox" id="navAccessibleToggle" checked style="width: 16px; height: 16px; cursor: pointer;">
        </label>
        <div id="navAccessibleStatus" style="margin-top: 4px; font-size: 11px; color: #28a745;">
          ♿ Prefers elevators and ramps
        </div>
      </div>

      <!-- Get Directions Button -->
      <button id="getDirectionsBtn" class="action-btn-wide outline" style="margin-bottom: 0; padding: 10px 16px; font-size: 14px;">
        <i data-lucide="route" style="width: 16px; height: 16px; margin-right: 6px;"></i>
        Get Directions
      </button>

      <!-- Clear Path Button -->
      <button id="clearPathBtn" style="display:none; width: 100%; padding: 10px; border: 1px solid #dc3545; background: white; color: #dc3545; border-radius: 6px; cursor: pointer; font-size: 14px;">
        <i data-lucide="x" style="width: 16px; height: 16px; margin-right: 6px;"></i>
        Clear Path
      </button>

      <!-- Turn-by-Turn Collapsible -->
      <div id="turnByTurnSection" style="display:none; margin-top: 12px;">
        <button id="toggleTurnByTurn" style="width: 100%; padding: 10px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; font-size: 14px; color: #333;">
          <span>
            <i data-lucide="list" style="width: 16px; height: 16px; margin-right: 6px;"></i>
            Turn-by-Turn Instructions
          </span>
          <i data-lucide="chevron-down" id="turnByTurnChevron" style="width: 16px; height: 16px;"></i>
        </button>
        <div id="turnByTurnContent" style="display:none; margin-top: 8px; padding: 12px; background: white; border-radius: 6px; border: 1px solid #ddd; max-height: 300px; overflow-y: auto;">
          <!-- Instructions will be inserted here -->
        </div>
      </div>
    </div>

    <div class="card-description" id="cardDescription">Description...</div>
    <div class="card-categories" id="cardCategories"></div>

    <!-- Secondary Actions at Bottom -->
    <div class="card-actions" id="cardActions" style="display:none;">
      <button class="action-btn secondary" id="websiteBtn">
        <i data-lucide="external-link" style="width: 16px; height: 16px; margin-right: 6px;"></i>
        Visit Website
      </button>
    </div>
  </div>

  <!-- Version Switcher Pill Button -->
  <a
    href="./react-app/"
    class="version-switcher"
    title="Switch to React + TypeScript version"
  >
    <i data-lucide="code-2" style="width: 16px; height: 16px;"></i>
    <span>React Version</span>
  </a>

  <style>
    .version-switcher {
      /* Hidden for client demo - React version not ready */
      display: none !important;

      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 10000;

      /* display: flex; */
      align-items: center;
      gap: 8px;

      padding: 10px 16px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border: 1px solid #e5e6ea;
      border-radius: 999px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);

      font-family: Inter, system-ui, -apple-system, sans-serif;
      font-size: 13px;
      font-weight: 600;
      color: #14b8a6;
      text-decoration: none;

      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
    }

    .version-switcher:hover {
      background: rgba(102, 126, 234, 0.1);
      border-color: #14b8a6;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(102, 126, 234, 0.2);
    }

    .version-switcher:active {
      transform: translateY(0);
    }

    /* Dark mode */
    @media (prefers-color-scheme: dark) {
      .version-switcher {
        background: rgba(28, 28, 30, 0.95);
        border-color: #38383a;
        color: #2dd4bf;
      }

      .version-switcher:hover {
        background: rgba(90, 142, 239, 0.1);
        border-color: #2dd4bf;
        box-shadow: 0 6px 16px rgba(90, 142, 239, 0.2);
      }
    }

    /* Mobile */
    @media (max-width: 768px) {
      .version-switcher {
        bottom: 12px;
        right: 12px;
        font-size: 12px;
        padding: 8px 12px;
      }

      .version-switcher span {
        display: none;
      }

      .version-switcher i {
        margin: 0;
      }
    }
  </style>

  <!-- Developer Debug Panel -->
  <div id="devDebugPanel" style="
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 350px;
    max-height: 600px;
    background: rgba(0, 0, 0, 0.95);
    color: #00ff00;
    font-family: 'Courier New', monospace;
    font-size: 11px;
    border: 2px solid #00ff00;
    border-radius: 8px;
    padding: 12px;
    z-index: 10000;
    display: none;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
  ">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border-bottom: 1px solid #00ff00; padding-bottom: 8px;">
      <h3 style="margin: 0; color: #00ff00; font-size: 14px;">🛠️ DEV TOOLS</h3>
      <button id="devPanelClose" style="
        background: none;
        border: 1px solid #00ff00;
        color: #00ff00;
        cursor: pointer;
        padding: 2px 8px;
        border-radius: 4px;
      ">✕</button>
    </div>

    <div id="devStats" style="margin-bottom: 12px;">
      <div style="color: #ffff00; font-weight: bold; margin-bottom: 4px;">📊 REAL-TIME STATS</div>
      <div id="devZoom">Zoom: <span style="color: #00ffff;">--</span></div>
      <div id="devExhibitors">Exhibitors: <span style="color: #00ffff;">0</span></div>
      <div id="devAmenities">Amenities: <span style="color: #00ffff;">0</span></div>
      <div id="devRestrooms">Restrooms: <span style="color: #00ffff;">0</span></div>
      <div id="devRooms">Rooms: <span style="color: #00ffff;">0</span></div>
      <div id="devFloor">Floor: <span style="color: #00ffff;">--</span></div>
    </div>

    <div id="devLastClick" style="margin-bottom: 12px; padding: 8px; background: rgba(0, 255, 0, 0.1); border-radius: 4px;">
      <div style="color: #ffff00; font-weight: bold; margin-bottom: 4px;">🖱️ LAST CLICK</div>
      <div id="devClickInfo" style="color: #00ffff; word-wrap: break-word;">None</div>
    </div>

    <div id="devEnvironment" style="margin-bottom: 12px;">
      <div style="color: #ffff00; font-weight: bold; margin-bottom: 4px;">🌍 ENVIRONMENT</div>
      <div id="devViewport">Viewport: <span style="color: #00ffff;">--</span></div>
      <div id="devIframe">In iframe: <span style="color: #00ffff;">--</span></div>
      <div id="devTouch">Touch: <span style="color: #00ffff;">--</span></div>
      <div id="devLucide">Lucide: <span style="color: #00ffff;">--</span></div>
    </div>

    <div id="devConsole" style="max-height: 200px; overflow-y: auto; padding: 8px; background: rgba(0, 0, 0, 0.5); border: 1px solid #00ff00; border-radius: 4px;">
      <div style="color: #ffff00; font-weight: bold; margin-bottom: 4px;">📝 ACTIVITY LOG</div>
      <div id="devLogContent" style="color: #00ffff; font-size: 10px;"></div>
    </div>
  </div>

  <!-- Debug Panel Toggle Button -->
  <button id="devDebugToggle" style="
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    background: rgba(0, 0, 0, 0.8);
    color: #00ff00;
    border: 2px solid #00ff00;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 9999;
    box-shadow: 0 2px 10px rgba(0, 255, 0, 0.5);
    transition: transform 0.2s, background 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
  " onmouseover="this.style.transform='scale(1.1)'; this.style.background='rgba(0, 255, 0, 0.2)';" onmouseout="this.style.transform='scale(1)'; this.style.background='rgba(0, 0, 0, 0.8)';">
    <i data-lucide="bug" style="width: 24px; height: 24px;"></i>
  </button>

  <!-- Initialize Lucide Icons -->
  <script>
    // Initialize all Lucide icons after DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      if (window.lucide) {
        lucide.createIcons();
        console.log('✅ Lucide icons initialized');
      }
    });
  </script>
</body>
</html>
